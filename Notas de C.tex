\documentclass[]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{multicol}
\usepackage{amssymb}

\geometry{a4paper,left=3cm,right=3cm,top=3cm,bottom=3cm}

%opening
\title{Notas de C}
\author{Logan Martinez}

\begin{document}
	
	\maketitle
	
	\begin{abstract}
		Pues estas son mis notas para aprender lenguaje de progamación `C' desde ``cero". Estas notas están respaldadas en un repositorio de Github.
	\end{abstract}
	
	\section{Introducción}
	
	\subsection{¿Que es C?}
	Es un lenguaje de programacionde medio nivel. ya que dispone de estrtucturas que son entendibles a simple vista como los lenguajes de alto nivel, pero tambien permite un control a bajo nivel. ya que permite controlar con facilidad disporitivos perifericos y optimizar el uso de memoria.
	
	\subsection{Historia de C}
	Desarrollado por Dennis Ritchie entre 1969 y 1972 en los laboratorios bell como evolución a su antecesor el lenguaje `B' y basado en el lenguaje ``BCPL".
	
	\subsection{Caracteristicas destacables}
	-Eficacia
	
	-Potencia
	
	-Eficiencia
	
	-Rapidez
	
	\subsection{¿Que temas contendrá el curso?}
	-Tipos de dato
	
	-Converciones
	
	-Bucles
	
	-Palabras reservadas
	
	-funciones
	
	-Asignacion de memoria
	
	-Directivas
	
	-Pilas
	
	-Colas
	
	-Arboles
	
	-Procesos
	
	-Creacion de libreria
	
	\section{Instalación y configuracion de entorno}
	
	\subsection{Configuracion}
	Necesitamos GCC, pero ¿Que es GCC? GCC es una coleccion de compiladores del proyecto GNU.
	
	Anteriormete GCC solo compilaba para C, pero posteriormente se extendio para C++, fortran, ada, objetics C, etc.
	
	\section{Hola mundo}
	
	\subsection{\#}
	Las lineas que comienzan con este simbolo $\left(\#\right)$ son procesadas por el preprocesador antes de que el programa se compile.
	
	\subsection{Caracter de escape}
	La diagonal invertda se le conoce como un caracter de escape. Cuando una diagonal invertida se encuentra dentro de una cadena de caracteres, el compilador lo verifica y lo convierte en usa secuencia de escape.
	
	\subsection{Practica}
	
	\begin{itemize}
		\item Ingresar a cdm
		\item entrar a la carpeta utilizando `cd' seguido de la direccion de la carpeta
		\item escribir en la consola ``gcc $($Nombre del archivo$)$.c $-$o $($nombre del archivo$)$.exe"
		\item escribir en la consola `dir'
		\item escribir en la consola `$($nombredel archivo$)$.exe'
	\end{itemize}
	
	\section{indef}
	
	\subsection{Operadores}
	
	\begin{itemize}
		\item $\left(\&\right)$ es un operador de dirección. por lo que indica la variable en la que se va a guardar esa información.
	\end{itemize}
	
	\subsubsection{Operadores Aritmeticos}
	
	\begin{itemize}
		\item suma $\left(+\right)$
		\item resta $\left(-\right)$
		\item multiplicacion $\left(*\right)$
		\item divición $\left(/\right)$
		\item modulo $\left(\%\right)$
	\end{itemize}
	
	\subsubsection{Operadores de igualdad}
	
	\begin{itemize}
		\item ==	`x' es igual que `y'
		\item  !=	`x' es diferente que `y'
	\end{itemize}
	
	\subsubsection{Operadores de relacion}
	
	\begin{itemize}
		\item $>$	`x' es mayor que `y'
		\item $<$	`x' es menor que `y'
		\item $>=$	`x' es mayor o igual que `y'
		\item $<=$	`x' es menor o igual que `y'
	\end{itemize}
	
	\subsection{Operador condicional}
	\begin{itemize}
		\item interrogación $\left(?\right)$ es similar al if-else
	\end{itemize}
	
	
	\subsection{Tipos de variable}
	$($\%$)$ se utiliza para indicar el tipo de variable.
	
	\begin{itemize}
		\item \%d significa que es una variable entera decimal.
		\item \%i significa que es una variable entera.
		\item \%c significa que es un caracter.
		\item \%li significa entero largo.
		\item \%.`numero de decimales'f significa numero real.
		\item \%.`numero de decimales'lf significa real largo.
		\item \%s Significa cadena de caracteres.
	\end{itemize}
	
	\subsection{Variables}
	
	\begin{itemize}
		\item \textbf{char} $($caracter$)$ es de tipo alphanumerico $($\%c$)$
		\item \textbf{int} $($entero$)$ $($\%i$)$
		\item \textbf{short} $($entero corto$)$ $($\%i$)$
		\item \textbf{unsigned int} $($entero positivo$)$ $($\%i$)$
		\item \textbf{long} $($entero largo$)$ $($\%li$)$
		\item \textbf{float} $($real$)$ $($\%f$)$
		\item \textbf{double} $($real con doble de rango$)$ $($\%f$)$
		
	\end{itemize}
	
	\subsection{Condicional}
	
	\begin{itemize}
		\item Se ultiliza if $($condición$)$ 
		
		$\lbrace$
		
		\slash*instruccion*\slash
		
		$\rbrace$
		
		\item else		$\lbrace$
		
		\slash*instruccion*\slash
		
		$\rbrace$ 
	\end{itemize}
	
	\section{Directivas del pre-procesador}
	
	Las librerias del pre-procesador son las que contienen librerias y macros. Todas las directivas comienzan con un simbolo de numeral $(\#)$.
	
	\subsection{\textit{Include}}
	
	\begin{itemize}
		\item \textbf{\#include} $<$stdio.h$>$ 
		
		\textbf{\#include} ``$($nombre del archivo$)$"
	\end{itemize}
	La diferencia entre ambas es la ubicacion en que el pre-procesador busca el archivo a incluir.\\
	
	Si el nombre del archivo se encierra entre comillas, el pre-procesador busca el archivo a incluir en el mismo directorio donde se encuentra el archivo que va a compilarse.\\
	
	Si el nombre del archivo se encierra entre llaves angulares va a buscarlos en los encabezados de la biblioteca estándar.
	
	\begin{itemize}
		\item math.h
		\item stdio.h
		\item stdlib.h
		\item time.h
		\item etc.
	\end{itemize}
	
	\subsection{\textit{Define}}
	La directiva \textbf{\#define} crea constantes simbólicas y macros.\\
	
	Ejemplos:
	
	\begin{itemize}
		\item PI 3.14159
		\item CUBO$($a$)$ a*a*a
	\end{itemize}
	
	\section{Palabras reservadas y conversion de tipos de dato}
	
	\subsection{Palabras reservadas}
	
	\begin{multicols}{5}
		\begin{itemize}
			\item char
			\item int
			\item float
			\item double
			\item long
			\item short
			\item signed
			\item unsigned
			\item void
			\item if
			\item else
			\item do
			\item while
			\item for
			\item switch
			\item case
			\item default
			\item break
			\item continue
			\item goto
			\item struct
			\item union
			\item enum
			\item typedef
			\item return
			\item auto
			\item extern
			\item register
			\item const
			\item static
			\item volatile
			\item sizeof
		\end{itemize}
	\end{multicols}
	
	\subsection{Conversion de tipos de dato}
	Para cambiar de tipo de dato se escribe.\\
	
	...
	
	printf$($``datos$\backslash$n",variable, $($tipo de dato$)$variable, $($tipo de dato$)$variable, ...$)$;
	
	\section{Funciones I}
	El concepto del lenguaje C esta basado en Bloques de construcción, estos bloques se llaman \textit{funciones}. un programa en C es una colección de 1 o mas funciones. En C una función es una subrutina que contiene una o mas sentencias y hace una o mas tareas. En un bien hecho programa en C, cada función hace una sola tarea.\\
	
	En general puedes dar a una función el nombre que quieras, a excepción de \textit{\textbf{main}} que está reservada para la función que inicia la ejecución de tu programa.
	
	\subsection{Función con argumentos}
	Una función argumento es simplemente un valor que es pasado a la función al mismo tiempo que este es llamado.\\
	
	Ejemplo:
	
	\#include $<$stdio.h$>$
	
	void sqr(int x)
	
	$\lbrace$
	
	printf(``\%d cuadrado es \%d$\backslash$n",x,x*x);
	
	$\rbrace$
	
	int main()$\lbrace$
	
	int num;
	
	num=100;
	
	sqr(num);
	
	return 0;
	
	$\rbrace$
	
	\subsection{Funciones que retornan valores}
	\#include $<$stdio.h$>$
	
	int mul(int a, int b)
	
	$\lbrace$
	
	return a*b;
	
	$\rbrace$
	
	int main()
	
	$\lbrace$
	
	int answer;
	
	answer = mul(10,11);
	
	printf(``\%d$\backslash$n",answer);
	
	return 0;
	
	$\rbrace$
	
	\subsection{Forma general de una funcion}
	\textit{return-type function-name} (\textit{parameter list})
	
	$\lbrace$
	
	\textit{body of code}
	
	$\rbrace$
	\\
	
	Para funciones sin parámetros, no habrá lista de ellos.
	
	\section{Ciclos}
	Cuando empezamos a hablar de ciclos hacemos referencia a que tendremos un mejor control del programa. La mayoría de los programas involucran un ciclo donde podemos tomar decisiones pero un poco mas controlado.
	
	\subsection{Ciclo \textit{for}}
	
	Ejemplo:
	
	...
	
	for$($i = 1;i $<$= 10;i++$)$
	
	$\lbrace$
	
	\slash*instrucciones*\slash
	
	$\rbrace$
	
	\subsection{Ciclo \textit{while}}
	Nos permite especificar una acción mientras la condición sea verdadera.\\
	
	\textbf{Ejemplo:\\}
	
	...
	
	int i=1;
	
	while$($i $<$= 10$)$
	
	$\lbrace$
	
	\slash*instrucciones*\slash
	
	i++;
	
	$\rbrace$
	
	
	
	\subsection{Ciclo \textit{Do while}}
	
	\textbf{Ejemplo:\\}
	
	...
	
	int i=1;
	
	do $\lbrace$
	
	\slash*instrucciones*\slash
	
	i++;
	
	$\rbrace$while$($i $<$= 10$)$;
	
	\section{\textit{Switch}}
	Consiste en un grupo de etiquetas \textbf{case} y un caso opcional \textbf{default} que nos va a permitir tener el control dependiendo de los casos que haya en nuestro programa.
	
	\subsection{Etiqueta case}
	Aquí se escribe el nombre del caso; Si es algún carácter debe ir entre comillas o si es un numero puede ser escrito sin ellas.\\
	
	\textbf{Ejemplo:\\}
	
	...
	
	int casos;
	
	printf$($``ingresa un numero\slash n"$)$;
	
	scanf$($``\%i", \&casos$)$;
	
	switch$($casos$)$
	
	$\lbrace$
	
	case 1:
	
	printf$($``elegiste el primer caso\slash n"$)$;
	
	break;\\
	
	case 2:
	
	printf$($``elegiste el segundo caso\slash n"$)$;
	
	break;\\
	
	case 3:
	
	printf$($``elegiste el tercer caso\slash n"$)$;
	
	break;\\
	
	case 4:
	
	printf$($``elegiste el cuarto caso\slash n"$)$;
	
	break;\\
	
	case 5:
	
	printf$($``elegiste el quinto caso\slash n"$)$;
	
	break;\\
	
	default:
	
	printf$($``no encontramos tu caso\slash n"$)$;
	
	break;
	
	$\rbrace$
	
	\section{Arreglos}
	Los arreglos son un conjunto de datos que se van almacenando dentro de una variable. Los arreglos nos permiten guardar muchos de estos datos; en estos casos los arreglos son conocidos como una unidad estática, ya que estos no cambiaran su tamaño durante la ejecución del programa.\\
	
	
	\subsection{Arreglo unidimensional}
	
	\textbf{Ejemplo:\\}
	...
	
	int sizeA;\\
	
	printf$($``tamaño del $\backslash$n"$)$;\\
	
	scanf$($``\%i",\&sizeA$)$;
	
	int age$[$sizeA$]$;
	
	for$($int i = 0;i $<$ sizeA;i++$)$
	
	$\lbrace$
	
	printf$($``ingresa el valor\%$\backslash$n",i+1$)$;
	
	scanf$($``\%i", \&age$[$i$]$$)$;
	
	$\rbrace$
	
	printf$($``los valores del arreglo son:$\backslash$n"$)$;
	
	for $($int i = 0; i $<$ sizeA;i++$)$
	
	$\lbrace$
	
	printf$($``\%i-", age$[$i$]$$)$;
	
	$\rbrace$
	
	printf$($``$\backslash$n"$)$;
	
	\subsection{Strings}
	Por mucho el uso mas común de un arreglo unidimensional es para crear cadenas de caracteres.
	
	La forma mas sencilla de ingresar una cadena desde el teclado es con la funcion \textbf{\textit{gets()}}\\
	
	Para ejemplos de funciones para strings ...$\backslash$learn c$\backslash$c string\_stuff.c
	
	\subsection{Arreglo multidimensional}
	
	\textbf{Ejemplo:\\}
	
	...
	
	\slash*
	
	col..	8	1	2
	
	fila0 	5	3	1
	
	fila1	6	4	2
	
	*\slash
	
	int multi$[$2$]$$[$3$]$ = $\lbrace$$\lbrace$5,3,1$\rbrace$,$\lbrace$6,4,2$\rbrace$$\rbrace$;
	
	printf$($``\%i$\backslash$n",multi$[$0$]$$[$2$]$$)$;\\
	
		Se pueden crear arreglos sin especificar el tamaño, en ese caso C se encarga de crear un arreglo lo suficientemente grande para mantener los datos en el.\\
	
	\textbf{Ejemplo:\\}
	
	char el[ ] = invalid imput;
	
	
	\section{\textit{Break} y \textit{Continue}}
	
	Nos permiten manejar el flujo de nuestro programa como queramos.\\
	
	Estos dos no son considerados como parte de la programación estructurada; sin embargo nos pueden sacar de un gran apuro en ocasiones.
	
	\begin{itemize}
		\item \textbf{break} termina la ejecución de algún ciclo.
		\item \textbf{continue} nos permite seguir ejecutando, pero salta un paso.
	\end{itemize}

	
	\subsection{\textit{Break}}
	
	\textbf{Ejemplo:\\}
	
	...
	
	int num =0;	
	
	while$($num$<$=7$)$
	
	$\lbrace$
	
	if$($num == 2$)$
	
	$\lbrace$
	
	break;
	
	$\rbrace$
	
	printf$($``\%i$\backslash$n",num$)$;
	
	num++;\\
	
	\textbf{En este caso se detiene el programa.}
	
	\subsection{\textit{Continue}}
	Permite ejecutar o continuar nuestro ciclo porque aun hay valores.
	
	Siempre se aumenta el valor antes del if, sino se cicla el programa y se detiene.\\
	
	\textbf{Ejemplo:\\}
	
	...
	
	int num =0;	
	
	while$($num$<$=7$)$
	
	$\lbrace$
	
	if$($num == 2$)$
	
	$\lbrace$
	
	break;
	
	$\rbrace$
	
	printf$($``\%i$\backslash$n",num$)$;
	
	num++;
	
	while$($num$<$=7$)$
	
	$\lbrace$
	
	if$($num == 2$)$
	
	$\lbrace$
	
	continue;
	
	$\rbrace$
	
	printf$($``\%i$\backslash$n",num$)$;\\
	
	\textbf{En este caso se salta el imprimir el numero 2.}
	
	
	\section{Funciones II}
	
	\subsection{Funciones básicas}
	
	
	\textbf{Ejemplo saludo:\\}
	
	...
	
	void saludo$()$
	
	$\lbrace$
	
	printf$($``Hola mundo$\backslash$n"$)$;
	
	return;
	
	$\rbrace$
	
	int main$()$$\lbrace$
	
	saludo$()$;
	
	return 0;
	
	$\rbrace$\\
	
	\textbf{Ejemplo suma:}
	
	int suma$()$;
	
	int main$()$;
	
	$\lbrace$
	
	printf$($``\%i$\backslash$n",suma$())$;
	
	return 0;
	
	$\rbrace$
	
	int suma $()$
	
	$\lbrace$
	
	int num1 =12;
	
	int num2 =4;
	
	int suma = num1 + num2;
	
	return suma;
	
	$\rbrace$
	
	\subsection{funciones de retorno}
	
	\textbf{Ejemplo:\\}
	
	...
	
	int suma$()$;
	
	int num3= 2;
	
	int main$()$;
	
	$\lbrace$
	
	int num1,num2;
	
	printf$($``ingresa el primer valor$\backslash$n"$)$;
	
	scanf$($``\%i",\&num1$)$;
	
	printf$($``ingresa el segundo valor$\backslash$n"$)$;
	
	scanf$($``\%i",\&num2$)$;
	
	printf$($``\%i$\backslash$n",suma$($num1,num2$))$;
	
	return 0;
	
	$\rbrace$
	
	int suma $($int num1, int num2$)$
	
	$\lbrace$
	
	int suma = num1 + num2 + num3;
	
	return suma;
	
	$\rbrace$
	
	\subsection{Funciones re-cursivas}
	
	Son funciones que tienen la propiedad de llamarse a si mismas.\\
	
	\textbf{Ejemplo del factorial de un número:\\}
	
	...
	
	\slash*
	
	5! = 5*4*3*2*1	o	5*4!
	
	4! = 4*3*2*1	o	4*3!
	
	3! = 3*2*1		o	3*2!
	
	2! = 2*1		o	2*1!
	
	1! = 1
	
	0! = 1
	
	*\slash\\
	
	long Factorial$($long numero$)$;
	
	int main$($$)$
	
	$\lbrace$
	
	int numero;
	
	printf$($``ingresa un número$\backslash$n"$)$;
	
	scanf$($``\%i",\&numero$)$;
	
	for $($int i = 0; i $<$= numero; ++i$)$
	
	$\lbrace$
	
	printf$($``\%ld$\backslash$n",Factorial$($i$)$$)$;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$
	
	long Factorial$($long numero$)$
	
	$\lbrace$
	
	if$($numero $<$= 1$)$
	
	$\lbrace$
	
	return 1;
	
	$\rbrace$else$\lbrace$
	
	return$($numero * Factorial$($numero-1$)$$)$;
	
	$\rbrace$
	
	$\rbrace$
	
	\subsection{Forma general de una función}
	
	La forma profecional de una funcion es:\\
	
	\textit{type-specifier function\_name(parameter declarations)}
	
	$\lbrace$
	
	\textit{body of the function}
	
	$\rbrace$\\
	
	El tipo de la función especifica el valor que retorna usando la sentencia \textbf{return}. Puede ser de cualquier tipo valido.La lista de declaración de parámetros es una lista de variables, con sus respectivos tipos y nombres separadas por comas que recibirán los valores de los argumentos cuando al función es llamada. Una función puede no tener parámetros, sin embargo aun son necesarios los paréntesis.
	
	Es importante entender que a diferencia de las variables, los parámetros deben de siempre incluir nombre y tipo. La forma correcta de hacerlo es por ejemplo:\\
	
	f(int x, int y, float z)$\lbrace$$\rbrace$
	
	\subsection{Sentencia return}
	
	La sentencia \textbf{return} tiene 2 importantes usos. Primero causará una salida inmediata de la función actual. Segundo, se puede usar para retornar un valor.
	
	\subsubsection{Retornando desde una función}
	
	Hay 2 maneras en las que una función termina la ejecución y retorna al llamador. La primera manera es cuando la ultima sentencia de la función es ejecutada y se encuentra con el final de la función. Por ejemplo, esta funcion simplemente imprime en sentido contrario en la pantalla:\\
	
	void pr\_reverse(char *s)
	
	$\lbrace$
	
	register int t;
	
	for(t = strlen(s)-1; t $>$ -1; t--) printf(''\%c", s[t]);
	
	$\rbrace$\\
	
	una vez la cadena es desplegada, la función no tiene mas que hacer, entonces regresa a el lugar desde que fue llamada.
	
	la segunda forma una en que funcion puede regresar es desde el uso de la sentencia \textbf{return}. La sentencia \textbf{return} puede ser usado sin algun valor asociado a el. Por ejemplo:\\
	
	void power(int base, int exp)
	
	$\lbrace$
	
	int i;
	
	if(exp < 0) return; /*Cant do negative exponents*/
	
	i = 1;
	
	for( ; exp; exp--) i = base*i;
	
	printf(''the answer is: \%d: ", i);
	
	$\rbrace$
	
	\subsubsection{Retornando un valor}
	
	Para retornar un valor desde una función, deberías seguir la sentencia \textbf{return} con el valor que será retornado. Por ejemplo, esta función retorna el valor máximo de sus 2 argumentos:\\
	
	max(int a, int b)
	
	$\lbrace$
	
	int temp;
	
	if(a $>$ b) temp = a;
	
	else temb = b;
	
	return temp;
	
	$\rbrace$\\
	
	Es posible que una función contenga 2 o mas sentencias \textbf{return}. Mas de un retorno es seguido usado para simplificar y hacer mas eficiente algún algoritmo. Por ejemplo:\\
	
	max(int a, int b)
	
	$\lbrace$
	
	if(a $>$ b) return a;
	
	else return b;
	
	$\rbrace$\\
	
	Es importante tener en cuenta que tener múltiples \textbf{return} puede des-estructurar  una función y hacer que su significado sea confuso. El mejor consejo es usar múltiples \textbf{return} solo cuando contribuyan de manera significativa al rendimiento de la función. todas las funciones, excepto las tipo \textbf{void} retornan un valor. Este valor está explícitamente especificada por la sentencia \textbf{return}.\\
	
	Como todas las funciones, excepto las tipo \textbf{void} retornan valores, cuando escribes programas, tus funciones generalmente serán de 3 tipos. El primero es simplemente computacional. Está específicamente diseñado para realizar operaciones en sus argumentos y retornan un valor basado en esa operación, en esencia es una función ''pura". Ejemplos de esto son la función \textbf{sqrt()} y \textbf{sin()}, que retornan el un numero raiz cuadrada y seno, respectivamente.
	
	El segundo tipo de funciones manipulan información y retorna un valor indicando el éxito o fallo de esa manipulación. Un ejemplo es \textbf{fwrite()}, que es usado para escribir información a un archivo de disco. Si la operación de escritura es exitosa \textbf{fwrite()} retorna el numero de cosas pediste sean escritos; cualquier otro valor, indica que un error ha ocurrido.
	
	El ultimo tipo de función no tiene un tipo explicito de valor de retorno. en esencia, la función es estrictamente procedimental y no produce valor. por turbias razones históricas, muchas veces funciones que realmente no producen un resultado interesante, retornan algo igualmente. Por ejemplo, \textbf{printf()} retorna el numero de caracteres escritos; seria muy inusual encontrar un programa que de hecho revise esto. Por lo tanto , aunque todas la funciones (excepto aquellas tipo \textbf{void}) retornan algo, no necesariamente tienes que utilizarlos para algo.
	
	\subsection{Funciones retornando valores no enteros}
	
	Cuando es necesario retornar diferentes tipos de datos a \textbf{int}se requiere un proceso de 2 pasos. Primero declarar la función; segundo, se le debe decir al compilador el tipo de la función antes de su primera llamada.
	
	Las funciones pueden ser declaradas para retornar cualquier tipo de dato valido en C. El método de declaración es similar a la de variables: el tipo especificado precede el nombre de la función, el especificador de tipo le dice al compilador que tipo de dato la función retorna. La mejor manera de informar al compilador sobre el tipo de retorno de una función es el usar un prototipo de función\\
	
	\subsubsection{Usando funciones prototipo}
	
	Una función prototipo realiza 2 tareas. Primero identifica el tipo de retorno de una función. Segundo especifica en tipo y numero de argumento que una función recibe. Tiene la siguiente forma general:\\
	
	\textit{type function-name(parameter list);}\\
	
	El parámetro por convención va cerca de la parte superior del programa o en un header file y debe ir antes de cualquier llamada se hace de la función.
	
	\subsubsection{Retornando punteros}
	
	Como cada tipo de dato puede tener una longitud diferente, el compilador debe saber que tipo de dato el apuntador está apuntando para apuntar al siguiente dato. Por lo tanto, una función que retorna un puntero debe ser declarado como ello. Por ejemplo aquí hay una función que retorna un puntero a una cadena en el lugar donde un carácter que coincide es encontrado:\\
	
	...$\backslash$learn c$\backslash$c pointer\_return.c\\
	
	\subsubsection{Funciones de tipo void}
	
	cuando una función no retorna un valor, puede ser declarada como tipo \textbf{void}. hacerlo evita su uso en cualquier expresión y ayuda a evitar errores accidentales. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c function\_void.c\\
	
	\subsection{Mas en prototipos}
	
	\subsubsection{Desajustes de argumento}
	
	Ademas de decir al compilador sobre el tipo de retorno de una función, un prototipo  también previene a la función de ser llamada con un tipo incorrecto o numero de argumentos. aunque C automáticamente convertirá el tipo de un argumento a el tipo del parámetro que está recibiendo, algunos tipos de conversión son simplemente ilegales. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c illegal\_argument.c\\
	
	Ademas, el usar prototipos de función, ayuda a encontrar bugs antes de que ocurra, reviniendo a una función el ser llamada con argumentos inválidos, también ayuda a verificar que tu programa trabaja correctamente, no permitiendo llamar funciones con el numero equivocado de argumentos.\\
	
	\subsubsection{Archivos de cabecera }
	
	Los archivos de cabecera contienen 2 principales cosas: ciertas definiciones usadas por las funciones y los prototipos de las funciones estándar relacionadas con el archivo de cabecera.
	
	\subsubsection{Forma general prototipos de función}
	
	La forma general de los prototipos de función es:\\
	
	\textit{tipo nombre(parametros);}\\
	
	En C es posible escribir un prototipo parcial de la funcion, evitando escribir los parametros, sin embargo esto no es valido para C++, por lo que se recomienda siempre evitar escribir un prototipo parcial de la funcion.
	
	\subsection{Reglas de alcance}
	
	Las reglas de alcance de un lenguaje son las reglas que gobiernan ya sea una pieza de código que sabe o tiene acceso a otra pieza de código o dato.
	
	En C, cada función es un bloque discreto de código. El código de una función es privado a otra función y no puede ser accesado por alguna sentencia en cualquier otra función, excepto por una llamada de esa función. El código que compromete el cuerpo de una función está escondido del resto del programa y a no ser que use variables o datos globales, no puede afectar ni ser afectado por otras partes del programa, excepto a la especificación de tu programa. Visto de otra manera, el código y los datos que están definidos en una función, no pude interactuar con el código o los datos definidos en otra función, a no ser sea explícitamente especificado, porque las 2 funciones tienen diferente alcance.
	
	Hay 3 tipos de variables: \textit{variables locales, parámetros formales} y \textit{variables globales}. Las reglas de alcance gobiernan como cada una de estas puede ser accesado por otras partes de tu programa u establece.
	
	\subsubsection{Variables locales}
	
	Las variables que son declaradas dentro de una función son llamadas \textit{variables locales}. Una variable puede ser declarada dentro de cualquier bloque de código y ser local en el. Lo mas importante de entender sobre variables locales es que exixten solo mientras el bloque de cofigo en el que fueron declarados se extá ejecutando. el bloque de codigo mas comun en el que las variables locales son declaradas es la funcion. Pir ejemplo:\\
	
	...$\backslash$learn c$\backslash$c local\_variables.c\\
	
	\subsubsection{Parámetros formales}
	
	Si una función usa argumentos, entonces deberían declararse variables que que acepten los valores de esos argumentos, estas se conforman como cualquier otra variable local, esto son los parámetros formales.
	
	\subsubsection{Variables globales}
	
	Las variables locales son conocidas durante toda la ejecución del programa, por lo que se pueden utilizar en cualquier bloque de código en el programa, como consecuencia de esto, mantienen su valor mientras no se le hagan asignaciones.
	
	Cuando una variable global y una variable local tienen el mismo nombre, todas las referencias a una variable con ese nombre dentro de la función donde se declara la variable local, se referirán a esa variable local. Ademas no afectará a la variable local, esto puede ser beneficioso, sin embargo puede hacer que tu programa actúe extraño aunque parezca estar bien.
	
	Deberías evitar usar variables globales innecesarias por 3 razones:
	
	\begin{itemize}
		\item Toman memora todo el tiempo en que tu programa se ejecuta, no solo cuando se necesita.
		\item Usando un global donde una variable local hará a una funcion menos general, pues depende en algo que se define fuera de si.
		\item Usar un gran numero de variables globales pueden llevar al programa errores por desconocidos y desagradables efectos secundarios.
	\end{itemize}
	
	Esta ultima razón esta evidenciada en BASIC, donde todas las variables son globales. Un grave problema desarrollando largos programas es accidentalmente cambiando el valor de una variable porque fue utilizada demasiadas variables globales en tu programa.
	
	Uno de los principales puntos de un lenguaje estructurado es la compartimentación de código y datos. En C compartimentación es lograda a través de el uso de funciones y variables locales. Por ejemplo:
	
	\begin{multicols}{2}
		\begin{itemize}
			\item Especifico
			
			int x, y;
			
			mul()

			$\lbrace$
			
			return (x*y);
			
			$\rbrace$
			
			\item General
			
			mul(int x, int y)
			
			$\lbrace$
			
			return (x*y);
			
			$\rbrace$
		\end{itemize}
	\end{multicols}
	
	Ambas funciones retornarán el producto de variables \textbf{x} y \textbf{y}. sin embargo, la versión generalizada o \textit{parametrizada} puede ser utilizada para retornar el producto de cualquier par de numeros, mientras que la version especifica puede ser utilizada para encontrar solo el producto de las variables globales \textbf{x} y \textbf{y}.
	
	\subsection{Funciones, parámetros y argumentos}
	
	\subsubsection{Llamada por valor, llamada por referencia}
	
	En general, subrutinas pueden ser pasados por argumentos en una de dos maneras. El primer método es llamado \textit{llamada por valor}. Este método copia el valor de un argumento en el parámetro formal de la subrutina. Por lo tanto, cambios hachos en el parámetro de la subrutina no tiene efectos en la variable usada para llamarla.
	
	\textit{Llamada por referencia} es la segunda manera en que a una subrutina se le puede pasar un argumento, la dirección de un argumento es copiado en el parámetro. Dentro de la subrutina, la dirección es usada para acceder al propio argumento usado en la llamada. esto significa que los cambios hechos a el parámetro afectara a la variable usada para llamar la rutina.
	
	\subsubsection{Creando una llamada por referencia}
	
	Aun cuando la convención en C para pasar parámetros es la llamada por valor, es posible crear una llamada por referencia pasando un puntero como argumento. Esto hace posible cambiar el valor de el argumento fuera de la función. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c pointers\_everywhere.c\\
	
	...$\backslash$learn c$\backslash$c llamada\_referencia.c\\
	
	En este punto deberías de haber podido entender porque tienes que poner \textbf{\&} enfrente de los argumentos para \textbf{scanf()}. De hecho lo que estas haciendo es pasar su dirección para que la variable llamada pueda ser modificada.\\
	
	\subsubsection{Llamado funciones con arreglos}
	
	Cuando un arreglo es pasado como argumento de una función, solo la dirección del arreglo se pasa, no se copia todo el arreglo. Cuando tu llamas una función con un arreglo nombre, un puntero a el primer elemento del arreglo se pasa a la función (recuerda, en C el nombre de un arreglo sin algún indice es un puntero al primer elemento de ese arreglo.) Esto significa que la declaración del parámetro debe ser compatible con un tipo puntero. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c pointer\_return.c\\
	
	...$\backslash$learn c$\backslash$c llamada\_arreglo.c\\
	
	Esto está permitido porque cualquier puntero puede ser indexado como si fuera un arreglo.
	
	Hay que reconocer que los 3 métodos de declarar un parámetro arreglo llevan al mismo resultado: un puntero.
	
	Un arreglo elemento usado como un argumento e tratado como cualquier otra variable. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c array\_element\_pointer.c\\
	
	\subsection{Argumentos de main}
	
	La forma general de pasar información a \textbf{main()} es a través de el uso de argumentos de la linea de comandos. Esto es la información que va después del nombre del programa(y su extensión).
	
	Hay 3 solamente maneras de construir argumentos a main. Los primeros 2 son \textbf{argc} y \textbf{argv} son usados para recibir argumentos en linea de comandos. El tercero es \textbf{env} y es utilizado para accesar a los parámetros activos ambientales DOS en el momento en que el programa comienza su ejecución.
	
	\textbf{argc()} almacena el numero de argumentos en la linea de comandos y es un entero, siempre será al menos 1, Porque el nombre del programa califica como primer argumento. El parametro \textbf{argv} es un puntero a un arreglo de cadenas. Todos los argumentos de linea de comandos son cadenas, cualquier numero tendrá que ser convertido por el programa al formato correcto. Por ejemplo:\\
	 
	...$\backslash$learn c$\backslash$c main\_argument.c\\
	
	Cada argumento de comando de linea debería ser separado por un espacio o un tab, comas, semi-columnas y similares no son considerados separadores.
	
	Se pueden ejecutar series de comandos DOS en la linea de comando. Esto se logra usando la función de librería \textbf{system()}. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c main\_arg\_system.c\\
	
	El parámetro \textbf{env} es declarado igual que el parametro\textbf{argv}. Este es un puntero a un arreglo de cadenas que contienen las configuraciones ambientales.
	
	\subsection{Retornando valores desde main()}
	
	Cuando retornas una valor entero desde \textbf{main()} se pasa al proceso de llamado, usualmente al sistema operativo. Para DOS y OS/2, un retorno de valor 0 indica una terminación exitosa del programa, cualquier otro valor indica que el programa termino debido a un error. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c return\_error\_main.c\\
	
	\subsection{recursion}
	
	En C y C++, las funciones pueden llamarse a si mismo. una función es re-cursiva si un estatuto en el cuerpo de la función se llama a si misma. cuando una función se llama a si mismo, nuevas variables locales y parámetros son guardados en el stack y el código de la función es ejecutada con estas nuevas variables desde el inicio. Una llamada re-cursiva no hace una copia de la función, solo se hacen nuevas variables y parámetros.
	
	la mayoría de las rutinas re-cursivas, no reducen significativamente el tamaño del código y el almacenamientos de variables, ademas de que la mayoría suelen ser un poco mas lentas que sus equivalentes iterativos, por la re-llamada de la función, sin embargo no es notable en la mayoría de los casos. Algunas funciones pueden causar \textit{stack overrun}, pero esto no es usual que pase yque cause un crash.
	
	la principal ventaja  de funciones re-cursivas es que pueden usarse para crear mal limpias y simples versiones de varios algoritmos que sus hermanos iterativos. por ejemplo el algoritmo de ordenamiento \textit{QuickSort}  es difícil de implementar de forma iterativa. también algunos problemas relacionados con \textit{AI} tienden a llevar a si mismos a soluciones re-cursiva. Finalmente, algunas personas suelen pensar que las formas re-cursivas son mas fáciles. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c recursivas.c
	
	\subsection{problemas de implementación}
	
	\subsubsection{parámetros y funciones de propósito general}
	
	Una función de propósito general es la que se utiliza en una amplia variedad de situaciones. Típicamente no deberías basar funciones de propósito general en datos globales, Es mucho mejor que cualquier cosa pasar toda la información una función necesita por sus parámetros.\\
	
	\subsection{Eficiencia}
	
	En ciertas especializaciones aplicaciones, quizá necesites eliminar una función y remplazarlo con \textit{codigo in-line}. Esto es equivalente a una sentencia de una función usada sin llamar a esa función.
	
	Existen 2 rezones de porque código in-line es mas rápido qe una función llamada. Primero, una instrucción llamada toma tiempo para ejecutar. Segundo, si hay argumentos para pasar, estos tienen que ser colocados en el stack, que también toma tiempo. Para la mayoría de aplicaciones, esto es un incremento muy bajo, sin embargo, pero cuando es para muy importantes tareas contra el tiempo es critico.
	
	\section{Apuntadores}
	
	\subsection{Conceptos básicos}
	Los apuntadores son variables cuyos valores son direcciones de memoria. por lo general una variable contiene directamente un valor en especifico; por otro lado un apuntador contiene la dirección de una variable que contiene un valor especifico.\\
	
	\textbf{Una variable apuntador se define como:\\}
	
	...
	
	int a = 2;
	
	int *apt = \&a;\\
	
	\textbf{Se imprime como:\\}
	
	...
	
	printf$($``\%i$\backslash$n",*apt$)$;\\
	
	\textbf{Para imprimir la dirección de memoria como un numero hexadecimal se hace:\\}
	
	...
	
	printf$($``\%p$\backslash$n",apt$)$;\\
	
	
	\subsubsection{Aritmética de apuntadores}
	
	Solo hay 2 tipos de operadores que deberian ser usados con apuntadores suma y resta de enteros. Cada incremento/decremento en un apuntador se guia por:
	\\
	
	ptr = ptr + (sizeof(tipo\_de\_dato) * n)
	
	\subsection{Apuntadores y arreglos}
	
	Existe una relación cercana entre arreglos y apuntadores, considera este fragmento.\\
	
	char str[80], *pl;\\
	
	pl = str;\\
	
	Aquí \textbf{pl} ha sido asignado a la dirección del primer elemento del arreglo \textbf{str}. otra forma de escribir esto es:\\
	
	pl = \&str[0];\\
	
	sin embargo  esta es considerada una forma pobre por mayor parte de los programadores de C, si quisieras accesar al quinto elemento en \textbf{str} podrias escribir:\
	
	str[4]\\
	
	o\\
	
	*(pl+4)\\
	
	Ambas maneras regresarán el quinto elemento.\\
	
	En C es posible indexar un apuntador como si fuera un arreglo. Esto hace mas evidente la cercana relación entre arreglos y apuntadores. Por ejemplo, este fragmento es completamente valido:\\
	
	int i[5] = $\lbrace$1, 2, 3, 4, 5$\rbrace$;
	
	int *p, t;\\
	
	p = i;\\
	
	for (t = 0; t $<$ 5; ++t)
	
	$\lbrace$
	
		printf("\%d$\backslash$n", p[t]);
		
	$\rbrace$\\
	
	En C, p[t] es idéntico a (p+t)\\
	
	Hasta ahora,  los ejemplos han estado concentrados en asignar la dirección de el inicio de un arreglo a un apuntador. Sin embargo, es posible asignar la dirección de un elemento especifico de un arreglo aplicando el \textbf{\&} a un arreglo indexado, por ejemplo este fragmento pone la dirección del tercer elemento de \textbf{x} en \textbf{p}:\\
	
	p = \&x[2];\\
	
	Un lugar donde esta practica es especialmente útil es en encontrar una sub-cadena. Por ejemplo, este programa imprimirá desde que el primer espacio es encontrado. ...$\backslash$learn c$\backslash$c array\_address.c\\
	
	\subsubsection{Arreglo de apuntadores}
	
	Apuntadores pueden ser arreglados así como harías con cualquier otro tipo de datos. La declaración de  un arreglo de punteros \textbf{int}  de tamaño 10 es:\\
	
	int *x[10];\\
	
	Para asignar la dirección de una variable entero a el tercer elemento de un arreglo puntero, escribirías\\
	
	x[2] = \&var;\\
	
	Para encontrar el valor de \textbf{var}, escribirías\\
	
	*x[2]\\
	
	un uso común de los arreglos punteros es el mantener punteros de mensajes de error. puedes crear una funcion que imprima un mensaje. Por ejemplo:\\
	
	char *err[ ] = $\lbrace$
	
	''cannot open fill$\backslash$n",
	
	''read error$\backslash$n",
	
	"write error$\backslash$n",
	
	"media failure$\backslash$n"
	
	$\rbrace$;\\
	
	void serror(int num)
	
	$\lbrace$
	
	printf ("\%s", err[num]);
	
	$\rbrace$\\
	
	Como puedes ver, \textbf{printf()} está dentro de \textbf{serror()} con un apuntador carácter, el cual apunta a uno de los varios mensajes de error indexados por el numero de error pasado de una función. Por ejemplo, si a \textbf{num} se le pasa 2, entonces el mensaje \textbf{write error} es desplegado.
	
	Otra interesante aplicación para los arreglos de punteros inicializados usa la función \textbf{system()} de C, que le permite a tu programa mandar un comando al sistema operativo. la llamada de \textbf{system()} tiene esta forma general\\
	
	\textbf{system}(''\textit{command}");\\
	
	Donde \textit{command} es el comando de sistema operativo a ejecutar. Por ejemplo, asumiendo un ambiente DOS, esta sentencia hace que el directorio default sea desplegado.\\
	
	system(''\textit{DIR}");\\
	
	El siguiente programa implementa un muy pequeño menu-driven user interface que puede ejecutar cuatro DOS comandos: DIR, CHKDSK, TIME Y DATE.\\
	
	...$\backslash$learn c$\backslash$c array\_of\_pointers.c\\
	
	Para una mejor ilustración de la inter-coneccion entre arreglos y punteros, desarrollaremos un simple programa traductor ingles a alemán.\\
	
	...$\backslash$learn c$\backslash$c english\_german.c\\
	
	El arreglo \textbf{trans} es de hecho un arreglo de punteros de las cadenas bajo su declaración.\\
	
	\subsection{Punteros a punteros}
	
	El concepto de arreglos de punteros es directo porque los indices mantienen su significado claro. Sin embargo, punteros a punteros pueden ser muy confusos.\\
	
	Un puntero a un puntero es una forma de \textit{indireccion multiple}, o cadena de punteros. Como puedes ver en la figura 8-3. (Using turbo C++, pg. 207), en el caso de un puntero normal, el valor de el puntero es la dirección de la variable que contiene el valor designado. En el caso de un puntero a un puntero el primer puntero contiene la dirección de el segundo puntero, el cual apunta a la variable, la cual contiene el valor designado.
	
	Indireccion múltiple puede ser llevada acabo en a manera deseada, pero hay algunos casos donde mas de un puntero a un puntero es necesario, o de hecho deseable usarlo. Excesiva indireccion es difícil de seguir y propensa a errores (no confundas múltiple indireccion ncon \textit{listas linkeadas} que se utilizan en base de datos y similares).\\
	
	una variable que es un puntero a un puntero debería ser declarado como ello. Esto se hace poniendo un asterisco adicional en frente de su nombre. Por ejemplo:\\
	
	float **newbalance;\\
	
	Es importante entender que \textbf{newbalance} no es un puntero a un floating-point number, sino un puntero a un puntero float.
	
	para acceder al valor apuntado apuntado indirectamente atravez de un puntero de un puntero, el operador asterisco debe ser aplicado dos veces como se ve en este pequeño ejemplo.\\
	
	...$\backslash$learn c$\backslash$c pointed\_pointer.c\\
	
	\subsection{Inicializar punteros}
	
	Después de que un puntero es declarado pero antes de asignarle un valor contendrá un valor indefinido. Si intentas usar un puntero antes de darle un valor probablemente crashearas no solo tu programa, sino también tu sistema operativo.\\
	
	por convención un puntero que apunta a nada debería de darse le un valor null, para dignificar que apunta a nada. Sin embargo, solo por que un puntero tenga un valor null no implica que sea ''seguro", si corres un puntero con valor nulo, aun corres el riesgo de crashear tu programa y el sistema operativo.
	
	porque un puntero nulo es asumido que permanecerá desusado, puedes usarlo para hacer muchas de tus rutinas de punteros mas fáciles de programar y mas eficientes. Por ejemplo, puedes usar un puntero nulo para marcar el final de un arreglo de punteros. si esto se hace, una rutina que accese ese arreglo sabrá que se ha alcanzado el final cuando el valor nulo es encontrado. Ejemplo:\\
	
	for(t = 0; p[t]; ++t)
	
	$\lbrace$
	
	if(!strcmp(p[t], name)) break;
	
	$\rbrace$\\
	
	Este es un ejemplo de una practica muy común en programación profesional de C. Otra variacion en este tema es el siguiente ejemplo de la declaracion de una cadena:\\
	
	char *p = ''hello world$\backslash$n";\\
	
	como puedes ver el puntero \textbf{p} no es un arreglo. La razon que este tipo de inicializacion funciona, tiene que ver con como C maneja cadenas constantes, los compiladores de C crean una tabla de cadenas donde  guardan las cadenas constantes usadas por el programa. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c null\_pointer.c\\
	
	sin embargo, tu programa no debe hacer asignaciones a la tabla de cadenas atraves de \textbf{p}, pues tu programa puede corromperse (NO ASIGNES VALORES NUEVOS AHI).\\
	
	\subsection{Problemas con punteros}
	
	Nada te traerá mas problemas que un puntero ''salvaje". punteros son un milagro mixto. ellos dan un tremendo poder y son necesarios para muchos programas, pero cuando un puntero accidentalmente contiene un valor equivocado, puede ser el bug mas difícil de encontrar.
	
	Un bug de puntero erróneo es difícil de encontrar porque el puntero en si no es el problema; el problema es que cada vez que intentas perforar una operación usándola, estas leyendo o escribiendo en una pieza desconocida de la memoria. Si tu lees de ella, lo peor que puede pasar el que tengas basura. Sin embargo, si escribes en ella puedes estar escribiendo sobre otras piezas de tu código o datos. Esto puede no mostrarse hasta después en la ejecución del programa y puede dirigirte a buscar el bug en el lugar equivocado. Esto puede dar muy poca a nada de evidencia sugiriendo que el puntero es el problema. Este tipo de bug ha causado a programadores perder tiempo y sueño.
	
	Porque errores de punteros son una pesadilla, deberías dar lo mejor por nunca generar uno. Para hacer la asignacion de una variable \textbf{x} a un puntero \textbf{p} debe de ser:\\
	
	p = \&x;\\
	
	o\\
	
	int *p = \&x\\
	
	Y se imprime:
	
	printf("\%d", *x);\\
	
	Si es un arreglo puede ser:
	
	p = i;,\\
	
	o\\
	
	int *p = i;\\
	
	o\\
	
	int *p = \&i[0];\\
	
	Y se imprime:
	
	printf("\%d", *x);\\
	
	Pero si es una cadena puede ser:
	
	printf(p);\\
	
	o\\
	
	printf("\%s", p);\\
	
	No evites utilizar punteros solo por que cuando son manejadas incorrectamente pueden causar bugs muy engañosos. Deberías ser cuidadoso y asegurarte de que sabes donde cada puntero apunta antes de usarlo.\\
	
	

	\subsection{Llamadas por referencia}
	Existen 2 maneras de pasar argumentos a una función.
	\begin{itemize}
		\item llamadas por valor
		\item llamadas por referencia
	\end{itemize}
	
	Hasta ahora hemos utilizado las funciones y hemos pasado los argumentos por valor, pero muchas funciones requieren la capacidad de modificar una o mas variables en una sola llamada de la función. En ese caso podemos evitar sobrecargas de pasar objetos por valor.
	
	Las sobrecargas en si es hacer copias del objeto o de nuestra variable.\\
	
	La diferencia es que las funciones se definen de tipo \textbf{void}, las cuales no están obligadas a devolver un valor.\\
	
	\textbf{Ejemplo:\\}
	
	...
	
	void cubo$($int *n$)$;
	
	int main$()$
	
	$\lbrace$
	
	int num = 5;
	
	printf$($``El valor original es: \%i$\backslash$n",num$)$;
	
	cubo$($\&num$)$;
	
	printf$($``El nuevo valor es: \%i$\backslash$n",num$)$;
	
	return 0;
	
	$\rbrace$
	
	void cubo$($int *n$)$
	
	$\lbrace$
	
	*n = *n * *n * *n;
	
	$\rbrace$
	
	\section{I/O y Archivos}
	
	\subsection{Streams y archivos}
	
	El sistema de C I/O provee un nivel de abstracción entre el programador y el artefacto usado. Esta abstracción es llamada \textit{stram} y el propio dispositivo es llamado \textit{archivo}. Es importante conocer como ellos interactuan.
	
	\subsection{Streams}
	
	El ANSI C sistema de archivos, está diseñado para trabajar en una gran variedad de dispositivos, incluyendo terminal, disk driver y tape drives. Aunque cada dispositivo es muy diferente, el ANSI C sistema de archivos, transforma cada uno en un dispositivo lógico llamado stream. todos los strams son similares en su comportamiento. Porque strams son ampliamente independientes de los dispositivos, la misma funcion que escribe en un archivo en disco puede también escribir en la consola, Existen 2 tipos de streams: texto y binario.
	
	\subsubsection{Streams de texto}
	
	Es una secuencia de caracteres. En un stream de texto, ciertos caracteres de traducción pueden ocurrir como requeridos por el ambiente anfitrión. Por ejemplo, una nueva linea puede ser convertida, de manera que el numero de caracteres escritos o leídos son necesariamente los mismos que encontramos en el dispositivo externo.
	
	\subsubsection{Streams binarios}
	
	Es una secuencia de bytes que tiene una correspondencia 1-a-1 a eso encontrado en el dispositivo externo. Eso es que no se hace traducción de caracteres. El numero de bytes escritos o leídos, será el mismo que el numero de bytes encontrados en el dispositivo externo. Sin embargo, streams binarios pueden estar repletos de bytes nulos para que llene un sector de un disco
	
	\subsubsection{Archivos}
	
	En C, un archivo es un concepto lógico que puede se aplicado a todo desde archivos de discos a terminales. Un stream está asociado con un especifico archivo, haciendo una operación abrir. Cuando se abre un archivo, información puede ser intercambiada entre archivo y programa.
	
	no todos los archivos tienen las mismas capacidades. Por ejemplo, un archivo de disco puede soportar acceso aleatorio mientras un disco de cinta no puede. Esto marca algo muy importante del sistema de C I/O: todos los streams son iguales, pero no todos los archivos son iguales.
	
	Si el archivo puede soportar acceso aleatorio (a veces llamado \textit{solicitud de posición}), entonces abrir ese archivo también inicia el \textit{indicador de posición de archivo} para empezar del archivo.
	
	\subsection{Conceptual contra real}
	
	Tan lejos como le concierne al programador, todo I/O pasa a traves de streams, que son las secuencias de caracteres. Todos los streams son lo mismo. el sistema de archivos une un stream con un archivo. En C, un archivo es cualquier dispositivo externo, capaz de I/O.
	
	\subsection{Consola I/O}
	
	Esto se refiere a operaciones que ocurren en el teclado y monitor de tu computadora.
	
	\subsubsection{Leyendo y escribiendo caracteres}
	
	Las funciones de consola I/O mas simples son \textbf{getche()}, que lee un caracter desde el teclado y \textbf{putchar()}, que imprime un caracter en la pantalla. La funcion \textbf{getche()} espera hasta que una tecla es presionada y entonces retorna un valor. La tecla presionada es ``echoed" a la pantalla automaticamente. La funcion \textbf{putchar()} escribirá un caracter argummento a la pantalla en la posicion actual del cursor. El prototipo de \textbf{putchar()} y \textbf{getche()} es este.\\
	
	int getche(void);\\
	
	int putchar(int c);\\
	
	...$\backslash$learn c$\backslash$c	putchar.c
	
	El archivo de cabecera de \textbf{getche()} es CONIO.H y el de \textbf{putchar()} es STDIO.H, El archivo de cabecera de la función \textbf{islower()} es CTYPE.H. Ejemplo:\\
	
	...$\backslash$learn c$\backslash$c case\_switcher.c\\
	
	Hay 2 importantes variaciones en \textbf{getche()}. El primero es \textbf{getchar()}, que es la función original basado en UNIX de ingresar caracteres. El problema con \textbf{getchar()} es que se cicla hasta que se ingresa un carácter, por ello su uso no es recomendado.
	
	la segunda y mas útil variación de \textbf{getche()} es \textbf{getch()}, que opera precisamente como \textbf{getche()}, excepto que el carácter no es impreso en la pantalla.
	
	\subsubsection{Leyendo y escribiendo cadenas}
	
	El siguiente paso en términos de complejidad y poder, están las funciones \textbf{gets()} y \textbf{puts()}. Estos permiten leer y escribir cadenas de caracteres en la consola.
	
	La función \textbf{gets()} lee una cadena de caracteres entradas y las escribe en la direccion apuntada por su argumento apuntador. El prototipo de \textbf{gets()} es:\\
	
	char *gets(char *s);\\
	
	La función gets retorna un puntero de \textbf{s}
	
	la función \textbf{puts()} escribe el argumento de su cadena en pantalla seguido por  una nueva linea. Su prototipo es:\\
	
	int puts(char *s);\\
	
	Reconoce los mismos códigos backslash como \textbf{printf()} como ''$\backslash$t" para tab. una llamada de \textbf{puts()} requiere mucho menos sobrecarga que la misma llamada de \textbf{printf()} porque \textbf{puts()} solo puede imprimir una cadena de caracteres- no puede imprimir números o hacer conversiones de formato. Por lo tanto la funcion \textbf{puts()} toma menos espacio y corre mas rapido que \textbf{printf()}. Por ejemplo:\\
	
	puts(''hello");\\
	
	La funcion \textbf{puts()} usa el archivo de cabecera STDIO.H
	
	\subsection{Consola I/O formateada}
	
	El prototipo de \textbf{printf()} es:\\
	
	int printf(char *control\_string,...)\\
	
	Notese los 3 puntos En el prototipo de \textbf{printf()}. cuando una función puede tomar un numero variable de argumentos, entonces su prototipo usa los tres puntos para especificar esto.
	
	En la función \textbf{scanf()} las cadenas serán leídos en arreglos de caracteres, y el nombre de un arreglo sin algún indice, es la dirección del primer elemento del arreglo. Entonces para leer una cadena en la dirección del arreglo de la caracteres, podrías usar lo siguiente:\\
	
	scanf(''\%s", address);\\
	
	En este caso \textbf{address} es ya un puntero, y no necesita ser precedido por el operador \&.
	
	Los datos de entrada deben ser separados por espacios, tabs o nuevas lineas. puntuación como comas, semi-columnas y similares, no cuentan como separadores. Esto significa que:\\
	
	scanf(''\%d\%d", \&r, \&c);\\
	
	Aceptará una entrada de 10 20, pero fallará con 10,20\\
	
	La función \textbf{scanf()} incluye un a característica muy poderosa llamada \textit{scanset}. un scanset define una lista de caracteres que serán alineados por \textbf{scanf()}. La función \textbf{scanf()} seguirá leyendo caracteres mientras estén en el scanset. Tan pronto como un carácter de entrada no se alinea con alguno del scanset, \textbf{scanf()} se mueve hacia el siguiente. Un scanset es se define poniendo una lista de los caracteres que quieras escanear dentro de paréntesis cuadrados. El inicio de los paréntesis cuadrados tiene como prefijo un signo de porcentaje, por ejemplo este scanset le dice a \textbf{scanf()} leer solo los dígitos desde 0 hasta 9:\\
	
	\%[1234567890] Esta declaración solo permitirá que esta cadena sea leída por la variable indicada\\
	
	Puedes especificar un rango dentro de una scanset usando un guion medio. por ejemplo:\\
	
	\%[A-Z]\\
	
	Esto le dice a \textbf{scanf()} que solo acepte caracteres desde A hasta Z. Ademas se puede especificar mas de un rango en el scanset. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c scanf\_range.c\\
	
	Algo importante de recordar es que scanset es case-sensitive, entonces si quieres poner mayúsculas y minúsculas individualmente.
	
	\subsection{El sistema ANSI I/O}
	
	El sistema ANSI I/O está compuesta de varias funciones interrelacionadas. Estas funciones requieren que el archivo de cabecera STDIO.H son incluidas por cualquier programa en donde son usadas.
	
	\subsubsection{El apuntador de archivo}
	
	Un común hilo que ata el sistema ANSI C I/O es el apuntador de archivo. Un apuntador e archivo es un puntero a información que define varias cosas sobre el archivo, incluyendo su nombre, estado y actual posición. En esencia, un archivo puntero identifica un archivo en disco duro y es usado por un stream asociado con el para la operación directa de funciones ANSI C I/O. un archivo puntero es un puntero de variable tipo \textbf{FILE}, que esta definido en STDIO.H. Para leer o escribir archivos, tu programa necesitará usar punteros de archivo. Para obtener variables puntero de archivo se utiliza una sentencia como la siguiente:\\
	
	FILE *fp:\\
	
	\begin{tabular}{l|l}
		\textbf{Function} & \textbf{Operation}\\
		\hline
		fopen() & Opens a stream\\[.7ex]
		fclose() & Closes a stream\\[.7ex]
		putc() & Writes a character on a stream\\[.7ex]
		getc() & Reads a character from a stream\\[.7ex]
		fseek() & Seeks to the specified sbyte in a stream\\[.7ex]
		fprintf() & Is to stream what \textbf{printf()} is to the console\\[.7ex]
		fscanf() & Is to stream what \textbf{scanf()} is to the console\\[.7ex]
		feof() & Returns true if the end of the file is reached\\[.7ex]
		ferror() & Returns true if an error has ocurred\\[.7ex]
		fread() & Reads a block of data from a stream\\[.7ex]
		fwrite() & Writes a block of data from a stream\\[.7ex]
		rewind() & Resets the file position locator to the begining of the file\\[.7ex]
		remove() & Erates a file
	\end{tabular}
	
	\subsubsection{Abriendo un archivo}
	
	La funcion \textbf{fopen()} sirve a dos propósitos. Primero abre un stream para usarlo y lo conecta a un archivo con ese stream. Segundo, retorna el archivo puntero asociado con ese archivo. Mas comunmenteel archivo es de disco. la funcion \textbf{fopen()} tiene este prototipo:\\
	
	FILE *fopen(char *nombre-archivo, char *modo);\\
	
	Donde \textit{modo} es una cadena conteniendo abierto el estado deseado. El nombre de archivo debe ser una cadena de caracteres que comprometa un nombre de archivo valido para el sistema operativo y debe incluir especificación de dirección
	
	\begin{tabular}{l|l}
		\textbf{Mode} & \textbf{Meaning}\\[.7ex]
		\hline
		''r" & Open a file for reading\\[.7ex]
		''w" & Create a file for writing\\[.7ex]
		''a" & Append to a file\\[.7ex]
		''rb" & Open a binary file for reading\\[.7ex]
		''wb" & Create a binary file for writing\\[.7ex]
		''ab" & Append to a binary file\\[.7ex]
		''r+" & Open a file for write/read\\[.7ex]
		''w+" & Create a file for read/write\\[.7ex]
		''a+" & Append or create a file fore read/write\\[.7ex]
		''r+b" & Open a binary file for read/write\\[.7ex]
		''w+b" & Create a binary file for read/write\\[.7ex]
		''a+b" & Append or create a binary file fore read/write\\[.7ex]
		''rt" & Open a text file for reading\\[.7ex]
		''wt" & Create a text file for writing\\[.7ex]
		''at" & Append to a text file\\[.7ex]
		''r+t" & Open a text file for read/write\\[.7ex]
		''w+t" & Create a text file for read/write\\[.7ex]
		''a+t" & Append or create a text file for read/write
	\end{tabular}
	
	Si quisieras abrir un archivo para escribir con nombre \textbf{test} entonces escribirias:\\
	
	FILE *fp;\\
	
	fp = fopen(''test", ''w");\\
	
	Sin embargo, usualmente lo varas escrito así:\\
	
	FILE *fp\\
	
	if ((fp = fopen(''test", ''w")) == NULL)
	
	$\lbrace$
	
	puts(''cannot open file$\backslash$n");
	
	exit(1);
	
	$\rbrace$\\
	
	La macro \textbf{NULL} está definida en STDIO.H. Este método detecta cualquier error abriendo un archivo, por ejemplo de protegido de escritura o disco lleno antes de intentar escribir en el. Un NULL es usado porque ningún archivo puntero tendría ese valor. También está la función \textbf{exit()}. Una llamada a \textbf{exit()} causa la inmediata terminación del programa, no importa de donde es llamada la función \textbf{exit()}, tiene un prototipo (encontrada en 	STDLIB.H):\\
	
	void exit(int \textit{val});\\
	
	Este valor es retornado al sistema operativo.
	
	Si usas \textbf{open()} para abrir un archivo para escribir, entonces cualquier archivo preexistente por ese nombre será borrado y comenzará un nuevo archivo. Si no existe un archivo por ese nombre, entonces uno será creado. Si quieres añadir a el final de un archivo, entonces debes usar el modo ''a". Abrir un archivo para leer operaciones, requiere que el archivo exista. Si no lo hace, un error será retornado. Finalmente, si un archivo es abierto para leer/escribir operaciones, este no será borrado si existe; sin embargo, si no existe se creará uno.
	
	\subsubsection{Escribir un caracter}
	
	la función \textbf{putc()} es usada para escribir caracteres a un stream previamente abierta para escribir por la función \textbf{fopen()} la función es declarada\\
	
	int putc(int \textit{ch}, FILE *\textit{fp});\\
	
	Donde \textit{fp} es el archivo puntero retornado por \textbf{fopen()} y \textit{ch} es el carácter de salida. El archivo puntero le dice a \textbf{putc()}que archivo de disco escribir en.Por razones históricas, \textit{ch} es formalmente llamado un \textbf{int} pero solo el byte de bajo orden es usado.
	
	Si una operación \textbf{putc()} es un éxito entonces va a retornar el carácter escrito. En un fallo, un \textbf{EOF} es retornado. \textbf{EOF} es un macro definido en STDIO.H que significa ''End-Of-File"
	
	\subsubsection{Leyendo un caracter}
	
	la función \textbf{getc()} es usado para leer caracteres de un stream abierto en modo de lectura por \textbf{fopen()}. la función es declarada como:\\
	
	int get(FILE *\textit{fp});\\
	
	Donde \textit{fp} es un archivo puntero de tipo \textbf{FILE} retornado por \textbf{fopen()}. Por razones históricas, \textbf{getc()} retorna un entero, pero el byte de alto orden es cero.
	
	la función \textbf{getc()} retornará una marca \textbf{EOF} cuando el final del archivo ha sido alcanzado o un error ha ocurrido. Por lo tanto para leer un archivo de texto hasta que la marca End-Of-File es leída, puedes  usar el siguiente codigo:\\
	
	ch = getc(fp);\\
	
	while(ch != EOF) $\lbrace$
	
	ch = getc(fp);
	
	$\rbrace$
	
	\subsubsection{Usando feof()}
	
	Un archivo de sistema ANSI puede también ser operado en dato binario. Donde una archivo es abierto por entrada binaria, es posible que un valor entero igual a la marca \textbf{EOF} puede ser leído. Esto causaría la previa rutina de indicar una condición EOF aun cuando el final físico de el archivo no ha sido alcanzado. Para resolver este problema, ANSI C incluye la función \textbf{feof()}, donde es usado para determinar el final de el archivo cuando se leen datos binarios. La función \textbf{feof()} tiene este prototipo:\\
	
	int feof(FILE *\textit{fp});\\
	
	Este prototipo está en STDIO.H. Retorna true si el final del archivo ha sido alcanzado; de otra manera, cero es retornado. Por lo tanto, la siguiente rutina lee un archivo binario hasta el final de que el final del archivo es encontrado.\\
	
	while(!feof(fp)) ch = getc(fp);\\
	
	por supuesto, este mismo método puede ser aplicado para archivos de texto así como archivos binarios.
	
	\subsubsection{Cerrando un archivo}
	
	La función \textbf{fclose()} es usado para cerrar un stream que ha sido abierto por una llamada a \textbf{fopen()}. Escribe cualquier dato aun en el búfer del disco (En informática, un búfer (del inglés, buffer) es un espacio de memoria, en el que se almacenan datos de manera temporal, normalmente para un único uso su principal uso es para evitar que el programa o recurso que los requiere, ya sea hardware o software, se quede sin datos durante una transferencia de datos I/O irregular o por la velocidad del proceso.) a el archivo y hace un cierre formal a nivel de sistema operativo en el archivo. fallar en el cierre de un stream invita a todo tipo de problemas incluyendo perdida de datos, destruir archivos y posibles intermitentes errores en tu programa. \textbf{fclose()} también cierra el archivo de bloque de control asociado con el stream y lo hace posible para rehúso. Posiblemente sea necesario cerrar on archivo antes de abrir otro.
	
	La funcion \textbf{fclose()} es declarada como:\\
	
	int fclose(FILE *\textit{fp});\\
	
	Donde \textit{fp} es el archivo puntero retornado por la llamada a \textbf{fopen()}. Un retorno de valor cero significa un exito cerrando operacion; cualquier otro valor indica error. Puedes usar la funcion estandar \textbf{ferror()} para determinar y reportar cualquier problema. Generalmente, el unico momento \textbf{fclose()} fallará es cuando un diskette (o su analogo moderno) ha sido prematuramente removido del drive o si no queda espacio en el diskette (o su analogo moderno).
	
	\subsubsection{ferror() y rewind()}
	
	la funcion \textbf{ferror()} es usada para determinar si una operación de archivo ha producido un error. Si un archivo es abierto en modo texto y un erroe en lectura o escritura ocurre, se retorna \textbf{EOF}. se usa \textbf{ferror()} para determinar que evento pasó. La funcion \textbf{ferror()} tiene el prototipo:\\
	
	int ferror(FILE *\textit{fp});\\
	
	Donde \textit{fp} es un archivo puntero valido. Retorna true si un error ha ocurrido durante la ultima operacion de archivo; retorn falso de otra manera. Porque cada operacion de archivo hace la condicion error, \textbf{ferror()} debería ser llamada inmediatamente despues de cada operacion de archivo; de otra manera, un error puede perderse. EL prototipo para \textbf{ferror()} está en STDIO.H.
	
	la funcion \textbf{rewind()} reseteará el localizador de posicion de archivo a el principio de el archivo especificado como su argumento. Su prototipo es:\\
	
	void rewind(FILE *\textit{fp});\\
	
	Donde \textit{fp} es un archivo punero valido. El prototipo para \textbf{rewind()} está en STDIO.H'
	
	\subsubsection{Usando fopen(), getc(), putc() y fclose()}
	
	las funciones \textbf{fopen()}, \textbf{getc()}, \textbf{putc()} y \textbf{fclose()} comprometen el minimo set de rutinas de archivo. Un simple ejemplo de usar \textbf{fopen()}, \textbf{putc()} y \textbf{fclose()} es el programa \textbf{ktod} abajo. Lee lacarteres desde el teclado y los escribe en un archivo de disco hasta que el signo de dolar es escito. EL archivo es especificado por el comando line. Por ejemplo, si llamas este programa \textbf{ktod}, entonces escribir \textbf{ktod test} te permitirá pasar lineas de texto hacia el archivo llamado test\\
	
	...$\backslash$learn c$\backslash$c ktod.c\\
	
	El programa complementar \textbf{dtos}, leerá cualquier archivo ASCII e imprime los contenidos en la pantalla.\\
	
	...$\backslash$learn c$\backslash$c dtos.c\\
	
	El siguiente programa copiará un archivo de cualquier tipo. Notese que los archivos son abiertos en modo binario y que \textbf{feof()} es usado para checar por el final del archivo.\\
	
	...$\backslash$learn c$\backslash$c feof.c\\
	
	\subsubsection{Using get() and putw()}
	
	En adición a \textbf{getc()} y \textbf{putc()}, están las funciones \textbf{putw()} y \textbf{getw()} estas funciones no están definidas por el ANSI C estardar. Estas son usadas para leer y escribir enteros de y desde un archivo de disco. Estas funciones trabajan exactamente como \textbf{putc()} y \textbf{getc()} excepto que en lugar de leer o escribir un solo carácter, estas leen o escriben un entero. Estas tienen el siguiente prototipo:\\
	
	int putw (int i, FILE *\textit{fp});\\
	
	int getw(FILE *\textit{fp});\\
	
	El siguiente fragmento de codigo escribirá un entero a el archivo de disco puntero por \textit{fp}:\\
	
	putw(10, fp);\\
	
	los prototipos por \textbf{getw()} y \textbf{putw} estan en STDIO.H\\
	
	\subsubsection{fgets() y fputs()}
	
	El sistema ANSI de C I/O incluye dos funciones que pueden leer y escribir cadenas desde streams: \textbf{fgets()} y \textbf{fputs()}. Sus prototipos se muestran aqui.\\
	
	char *fputs(char *str, FILE *\textit{fp});
	
	char *fgets(char *str, int \textit{length}, FILE *\textit{fp});\\
	
	La función \textbf{fputs()} trabaja como \textbf{puts()} excepto que escribe la cadena el el stream especificado. La funcion \textbf{fgets()} lee una dadena desde el stream especificado hasta que un caracter nueva linea es leido o hasta que carecteres \textit{length-1} han sido leidos. Si una nueva liea es leida, se volverá parte de la cadena. La cadena resultante será terminacion null.
	Los prototipos para \textbf{fgets()} y \textbf{fputs()} están en STDIO.H.
	
	\subsubsection{fread() y fwrite()}
	
	El sistema ANSI I/O provee dos funciones, llamadas \textbf{fread()} y \textbf{fwrite()}, que permiten la lectura y escritura de bloques de daos. Sus prototipos se miestran aquí:\\
	
	unsigned fread(void *\textit{buffer}, int \textit{num\_bytes}, int \textit{count}, FILE *\textit{fp});\\
	
	unsigned fwrite(void *\textit{fbuffer}, int \textit{num\_bytes}, int \textit{cout}, FILE *\textit{fp});\\
	
	En el caso de \textbf{fread()}, \textit{buffer} es un puntero a una región de memoria que va a recibir los datos desde el archivo. Para \textbf{fwrite()}, \textit{buffer} es un puntero a la información que será escrito en  el archivo. El numero de bytes a ser leídos o escritos es especificado por \textit{num\_bytes}. El argumento \textit{count} determina cuantos objetos pueden ser leidos o escritos. Finalmente, \textit{fp} es un archivo puntero a un stream abierto previamente. Ambas funciones tienen sus protipos en STDIO.H.
	
	La funcion \textbf{fread()} retorna el numero de objetos leidos, que pueden ser menos que \textit{count} si el final de el archivo es alcanzado o un error ocurrio. La funcion \textbf{fwrite()} retorna el numero de objetos escritos. Este valor será igual a \textit{count} a no ser que un error ocurra.
	 
	Mientras el archivo sea abierto como dato binario, \textbf{fread()} y \textbf{fwrite()} pueden leer y escribir cualquier tipo de informacion. Por ejemplo este programa escribe un \textbf{float} en el disco:\\
	 
	...$\backslash$learn c$\backslash$c fwrite\_fread.c\\
	 
	Como este programa ilustra, el buffer puede ser y seguido es, un a simple variable. Este programa tambien  introduce otro operador de C: \textbf{sizeof}. El operador de tiempo de compilación \textbf{sizeof} retorna el tamaño en bytes de la variable o el tipo de dato que precede.
	 
	una de las mas utiles aplicaciones de \textbf{fread()} y \textbf{fwrite()} involucra leer y escribir arreglos (o como verás despues, estructuras). Por ejemplo. este fragmento escribe los contenidos de un arreglo de punto flotante \textbf{sample} a el archivo \textbf{sample} usando un solo \textbf{fwrite()}:\\
	 
	...$\backslash$learn c$\backslash$c sample\_read.c
	 
	\subsubsection{fseek() y acceso aleatorio I/O}
	 
	Puedes hacer lectura y escritura aleatoria de operaciones usando el sistema ANSI C I/O con la ayuda de \textbf{fseek()}, que establece el localizador de posición del archivo. Su prototipo es:\\
	 
	int fseek(FILE *\textit{fp}, long \textit{numbytes}, int \textit{origin});\\
	 
	Aquí \textit{fp} es un archivo puntero retornado por una llamada a \textbf{fopen()}; \textit{numbytes} un entero long es el numero de bytes desde \textit{origin} para hacer la posicion actual; \textit{origin} es uyno de los siguientes macros definidos en STDIO.H:\\
	 
	\begin{tabular}{l|l|l}
		\textbf{Origin} & \textbf{Macro Name} & \textbf{Actual Value}\\
		\hline
		Begining of file & SEEK\_SET & 0\\[.7ex]
		Current position & SEEK\_CUR & 1\\[.7ex]
		End of file & SEEK\_END & 2
	\end{tabular}\\

	Por lo tanto para buscar \textit{numbytes} desde el inicio del archivo, \textit{origin} debería ser \textbf{SEEK\_SET}, para buscar desde la posicion actual debería ser \textbf{SEEK\_CUR}, para buscar desde el final debería ser \textbf{SEEK\_END}.\\
	
	El siguiente fragmento lee el byte 235 en un archivo que es llamado \textbf{test}.\\
	
	...
	
	FILE *fp;
	
	char ch;\\
	
	if((fp = fopen(''test", ''rb")) == NULL) $\lbrace$
	
	printf(Cannot open file$\backslash$n);
	
	exit(1);
	
	$\rbrace$\\
	
	fseek(fp, 234, 0);
	
	ch = getch(fp);
	
	...\\
	
	Un valor 0 de retorno  significa que \textbf{fseek()} tuvo éxito. Un valor diferente de 0 indica fallo.\\
	
	Un mas interesante ejemplo es el programa \textbf{DUMP}, que usa \textbf{fseek()} para dejarte examinar los contenidos en ASCII y hexadecimal de cualquier archivo elijas. Puedes mirar el archivo en sectores de 128bytes en cualquier dirección. La salida es similar en estilo a el formato usado por DEBUG cuando dado el comando ''D" (dump memory)
	


	\section{Operador SizeOf}
	
	\textbf{C} proporciona el operador unitario \textbf{sizeof} para determinar el tamaño en bytes de un arreglo o cualquier otro tipo de dato durante la compilación del programa.
	
	\subsubsection{\textit{size\_t}}
	
	Es un tipo definido por el estándar de \textbf{C} como un tipo entero y el valor que debemos de retornar no debe tener signo entonces van a ser puros valores positivos.\\
	
	\textbf{Ejemplo:\\}
	
	...
	
	size\_t getsize$($float *ptr$)$;
	
	int main$()$
	
	$\lbrace$
	
	float array$\lbrack$20$\rbrack$;
	
	printf$($``El número de bytes en el arreglo es: \%lu$\backslash$n",sizeof$($array$))$;
	
	printf$($``El número de bytes devueltos por getsize es: \%lu$\backslash$n",getsize$($array$))$;
	
	return 0;
	
	$\lbrace$
	
	size\_t getsize$($float *ptr$)$
	
	$\lbrace$
	
	return sizeof$($ptr$)$;
	
	$\rbrace$
	
	\section{Estructuras}
	
	Una estructura es la colección de uno o mas elementos denominados miembros; estos pueden ser de un tipo de dato diferente. para declarar una estructura debemos utilizar la palabra reservada \textbf{struct}. para poder definir una estructura debemos de ponerle un nombre. en este caso las estructuras son muy parecidas a los objetos.\\
	
	\textbf{Ejemplo:\\}
	
	...
	
	struct perro
	
	$\lbrace$
	
	char nombre$[$30$]$;
	
	int edadmeses;
	
	float peso;
	
	$\rbrace$perro1=$\lbrace$``gato",10,3.50$\rbrace$,
	
	perro2=$\lbrace$``roberto",4,2.30$\rbrace$;
	
	int main$()$
	
	$\lbrace$
	
	printf$($``El peso de \%s es \%.2f kg y tiene \%d meses $\backslash$n",perro2.nombre,perro2.peso,perro2.edadmeses);
	
	return 0;
	
	$\rbrace$
	
	\subsection{Arreglo de estructuras}
	
	\textbf{Ejemplo:\\}
	
	...
	
	struct perro
	
	$\lbrace$
	
	char nombre$[$30$]$;
	
	int edadmeses;
	
	float peso;
	
	$\rbrace$perros$[$3$]$;
	
	int main$()$
	
	$\lbrace$
	
	for $($int i = 0; i $<$ 3; ++i$)$
	
	$\lbrace$
	
	printf$($``\%iIngresa el nombre del perro$\backslash$n",i+1$)$;
	
	scanf$($``\%s",\&perros$[$i$]$.nombre$)$;
	
	printf$($``\%iIngresa la edad del perro$\backslash$n",i+1$)$;
	
	scanf$($``\%i",\&perros$[$i$]$.edadmeses$)$;
	
	printf$($``\%iIngresa el peso del perro$\backslash$n",i+1$)$;
	
	scanf$($``\%f",\&perros$[$i$]$.peso);
	
	$\rbrace$
	
	for $($int i = 0; i $<$ 3; ++i$)$
	
	$\lbrace$
	
	printf$($``\%i El nombre del perro es: \%s$\backslash$n",i+1,perros$[$i$]$.nombre$)$;
	
	printf$($``\%i La edad del perro es: \%i$\backslash$n",i+1,perros$[$i$]$.edadmeses$)$;
	
	printf$($``\%i El peso del perro es: \%.2f$\backslash$n",i+1,perros$[$i$]$.peso$)$;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$
	
	\subsubsection{Operador punto}
	
	Cada vez que declaramos un arreglo de estructuras para acceder a una variable utilizamos el punto.
	
	\subsection{Estructuras anidadas}
	Las estructuras anidadas siempre se encuentran dentro de otra estructura.\\
	
	\textbf{Ejemplo:\\}
	
	...
	
	\#define length 2
	
	struct owner
	
	$\lbrace$
	
	char nombre$[$20$]$;
	
	char direccion$[$30$]$;
	
	$\rbrace$;
	
	struct dog
	
	$\lbrace$
	
	char nombre$[$20$]$;
	
	int edadmeses;
	
	struct owner ownerDog;
	
	$\rbrace$dogs$[$length$]$;
	
	int main$()$
	
	$\lbrace$
	
	for $($int i = 0; i $<$ length; ++i$)$
	
	$\lbrace$
	
	printf$($``Nombre del perro$\backslash$n"$)$;
	
	scanf$($``\%s",dogs$[$i$]$.nombre$)$;
	
	printf$($``Edad del perro en meses$\backslash$n"$)$;
	
	scanf$($``\%i",\&dogs$[$i$]$.edadmeses$)$;
	
	printf$($``Nombre del dueño$\backslash$n"$)$;
	
	scanf$($``\%s",dogs$[$i$]$.ownerDog.nombre$)$;
	
	printf$($``direccion$\backslash$n"$)$;
	
	scanf$($``\%s",dogs$[$i$]$.ownerDog.direccion$)$;
	
	printf$($``$\backslash$n"$)$;
	
	$\rbrace$
	
	for $($int i = 0; i $<$ length; ++i$)$
	
	$\lbrace$
	
	printf$($``El nombre del perro es: \%s$\backslash$n",dogs$[$i$]$.nombre$)$;
	
	printf$($``Edad en meses del perro: \%i$\backslash$n",dogs$[$i$]$.edadmeses$)$;
	
	printf$($``Nombre del dueño \%s$\backslash$n",dogs$[$i$]$.ownerDog.nombre$)$;
	
	printf$($``La direccion es: \%s$\backslash$n",dogs$[$i$]$.ownerDog.direccion$)$;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$
	
	\section{Asignación dinámica de memoria}
	
	La memoria es un espacio que reserva nuestra computadora para almacenar algun valor o dato.\\
	
	\textbf{Podemos encontrar:}
	
	\begin{itemize}
		\item Memoria estática
		\item Memoria dinámica
	\end{itemize}
	
	La \textbf{memoria estática} es la que venimos utilizando donde no nos preocupamos por el uso excesivo de la memoria. El problema viene cuando no utilizamos toda la memoria que se le fue asignada; por lo tanto la desperdiciamos, no estamos optimizando nuestro programa para poder utilizar un mínimo de memoria, por lo que tenemos la opción de asignar la memoria dinámica-mente.\\
	
	La \textbf{memoria dinámica $($malloc$)$} es un tipo de memoria que se reserva en tiempo de ejecución, así que su tamaño puede variar al momento de ejecutarse. Es importante utilizarlo cuando no sabemos el numero de datos o elementos que va a contener nuestro programa. Para utilizar malloc es necesario llamar a la librería \textit{stdlib.h}\\
	
	\textbf{Ejemplo 1:\\}
	
	...
	
	int main$()$
	
	$\lbrace$
	
	int n=10;
	
	char * p;
	
	p = malloc$($n*sizeof$($char$))$;
	
	if $($NULL == p$)$
	
	$\lbrace$
	
	printf$($``Error al asignar memoria$\backslash$n"$)$;
	
	$\rbrace$else$\lbrace$
	
	printf$($``Se asignó memoria$\backslash$n"$)$;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$\\
	
	
	\textbf{Ejemplo 2:\\}
	
	\#define length 2
	
	int size;
	
	struct dog
	
	$\lbrace$
	
	char name$[$20$]$;
	
	char *p\_name;
	
	$\rbrace$dogs$[$length$]$;
	
	int main$()$
	
	$\lbrace$
	
	for $($int i = 0; i $<$ length; ++i$)$
	
	$\lbrace$
	
	printf$($``Ingrese el nombre del perro$\backslash$n"$)$;
	
	scanf$($``\%s",dogs$[$i$]$.name$)$;
	
	size = strlen(dogs[i].name);
	
	printf$($``\%i$\backslash$n",size$)$;
	
	dogs$[$i$]$.p\_name = malloc$($size * sizeof$($char$))$;
	
	if $($NULL == dogs$[$i$]$.p\_name$)$
	
	$\lbrace$
	
	printf$($``Error al asignar memoria$\backslash$n"$)$;
	
	$\rbrace$else$\lbrace$
	
	strcpy$($dogs$[$i$]$.p\_name,dogs$[$i$]$.name$)$;
	
	$\rbrace$
	
	$\rbrace$
	
	for $($int i = 0; i $<$ length; ++i$)$
	
	$\lbrace$
	
	printf$($``El nombre del perro es: \%s$\backslash$n",dogs$[$i$]$.p\_name$)$;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$
	
	\subsection{Liberar memoria dinámica}
	
	\subsection{\textit{`fgets' y `free'}}
	
	\textit{\textbf{free}} es lo que se utiliza para liberar la memoria el cual solo necesita de la variable o el apuntador que se va a liberar como parámetro. Como opción a la utilización de \textit{\textbf{scanf}} podemos utilizar \textit{\textbf{gets}}, el cual solo necesita un parámetro que es la dirección de donde se van a archivar los datos; pero puede ser inseguro pues no limita la cantidad de datos que entran al escanear sino se le especifica al arreglo. Sin embargo para evitar este problema utilizamos \textit{\textbf{fgets}} el cual necesita de 3 parámetros:\\
	
	\begin{itemize}
		\item El puntero o la variable donde se va a almacenar la información.
		\item El tamaño de lo que esperamos recibir.
		\item De donde se van a obtener esos datos.
	\end{itemize}
	
	
	
	\subsubsection{Operador}
	
	Cuando hacemos referencia a un puntero utilizamos el operador $->$ haciendo una pequeña flechita. Y de esta forma podemos liberar la memoria de la variable a la que apunta la flecha, pero si tratamos de acceder a ella nos va a ocasionar un problema.\\
	
	\textbf{Ejemplo:\\}
	
	\#include $<$stdio.h$>$
	
	\#include $<$stdlib.h$>$
	
	\#include $<$string.h$>$
	
	\#define length 2
	
	int size;
	
	struct dog
	
	$\lbrace$
	
	char name$[$20$]$;
	
	char *p\_name;
	
	$\rbrace$dogs$[$length$]$;
	
	int main$()$
	
	$\lbrace$
	
	for $($int i = 0; i $<$ length; ++i$)$
	
	$\lbrace$
	
	printf$($``Ingrese el nombre del perro$\backslash$n");
	
	fgets$($dogs$[$i$]$.name,20,stdin$)$;
	
	size = strlen$($dogs$[$i$]$.name$)$;
	
	printf$($``\%i$\backslash$n",size$)$;
	
	dogs$[$i$]$.p\_name = malloc$($size * sizeof$($char$))$;
	
	if $($NULL == dogs$[$i$]$.p\_name$)$
	
	$\lbrace$
	
	printf$($``Error al asignar memoria$\backslash$n"$)$;
	
	$\rbrace$else$\lbrace$
	
	strcpy$($dogs$[$i$]$.p\_name,dogs$[$i$]$.name$)$;
	
	free$($dogs$[$i$]$.name$)$;
	
	$\lbrace$
	
	$\rbrace$
	
	for $($int i = 0; i $<$ length; ++i$)$
	
	$\lbrace$
	
	printf$($``El nombre del perro es: \%s$\backslash$n",dogs$[$i$]$.p\_name$)$;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$
	
	\section{Listas enlazadas}
	
	Son una colección de estructuras autorreferenciadas llamadas \textit{\textbf{nodos}}. en las listas enlazadas podemos guardar y eliminar datos en tiempo de ejecución y no es necesario definir cuantos espacios va a tener nuestra lista.\\
	
	En esta definición hablamos de estructuras autorreferenciadas. >Que es una estructura autorreferenciada? Una estructura autorreferenciada contiene un miembro apuntador el cual apunta a una estructura del mismo tipo.\\
	
	Ahora >Que es un nodo en C? Un nodo en C es una estructura que se crea con memoria dinámica; también al momento en que creamos estructuras nos podemos encontrar con algo llamado \textit{\textbf{typedef}} que se antepone a la estructura nos permite crear sinónimos para nuestras estructuras.\\
	
	\textbf{Ejemplo:}
	
	\#include $<$stdio.h$>$
	
	\#include $<$stdlib.h$>$
	
	typedef struct nodo
	
	$\lbrace$
	
	char *nombre;
	
	struct nodo *sig;
	
	$\rbrace$Libro;
	
	Libro *listaLibro$($Libro *Lista$)$$\lbrace$
	
	Lista = NULL;
	
	return Lista;
	
	$\rbrace$
	
	Libro *agregarLibro$($Libro *Lista, char *nombre$)$$\lbrace$
	
	Libro *nuevoLibro, *aux;
	
	nuevoLibro = $($Libro*$)$malloc$($sizeof$($Libro$))$;
	
	nuevoLibro$->$nombre = nombre;
	
	nuevoLibro$->$sig = NULL;
	
	if $($Lista == NULL$)$
	
	$\lbrace$
	
	Lista = nuevoLibro;
	
	$\rbrace$else$\lbrace$
	
	aux = Lista;
	
	while$($aux$->$sig !=NULL$)$$\lbrace$
	
	aux = aux$->$sig;
	
	$\rbrace$
	
	aux$->$sig = nuevoLibro;
	
	$\rbrace$
	
	return Lista;
	
	$\rbrace$
	
	int main$()$
	
	$\lbrace$
	
	Libro *Lista = listaLibro$($Lista$)$;
	
	Lista = agregarLibro$($Lista,``HTML5 Avanzado"$)$;
	
	Lista = agregarLibro$($Lista,``CSS3 Avanzado"$)$;
	
	while$($Lista != NULL$)$$\lbrace$
	
	printf$($``\%s$\backslash$n",Lista$->$nombre$)$;
	
	Lista = Lista$->$sig;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$
	
\end{document}$