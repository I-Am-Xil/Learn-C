\documentclass[]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{multicol}
\usepackage{amssymb}
\usepackage{hyperref}

\geometry{a4paper,left=3cm,right=3cm,top=3cm,bottom=3cm}

%opening
\title{Notas de C}
\author{Logan Martinez}

\begin{document}
	
	\maketitle
	
	\begin{abstract}
		Pues estas son mis notas para aprender lenguaje de progamación `C' desde ``cero". Estas notas están respaldadas en un repositorio de Github.
	\end{abstract}
	
	\section{Introducción}
	
	\subsection{¿Que es C?}
	Es un lenguaje de programacionde medio nivel. ya que dispone de estrtucturas que son entendibles a simple vista como los lenguajes de alto nivel, pero tambien permite un control a bajo nivel. ya que permite controlar con facilidad disporitivos perifericos y optimizar el uso de memoria.
	
	\subsection{Historia de C}
	Desarrollado por Dennis Ritchie entre 1969 y 1972 en los laboratorios bell como evolución a su antecesor el lenguaje `B' y basado en el lenguaje ``BCPL".
	
	\subsection{Caracteristicas destacables}
	-Eficacia
	
	-Potencia
	
	-Eficiencia
	
	-Rapidez
	
	\subsection{¿Que temas contendrá el curso?}
	-Tipos de dato
	
	-Converciones
	
	-Bucles
	
	-Palabras reservadas
	
	-funciones
	
	-Asignacion de memoria
	
	-Directivas
	
	-Pilas
	
	-Colas
	
	-Arboles
	
	-Procesos
	
	-Creacion de libreria
	
	\section{Instalación y configuracion de entorno}
	
	\subsection{Configuracion}
	Necesitamos GCC, pero ¿Que es GCC? GCC es una coleccion de compiladores del proyecto GNU.
	
	Anteriormete GCC solo compilaba para C, pero posteriormente se extendio para C++, fortran, ada, objetics C, etc.
	
	\section{Hola mundo}
	
	\subsection{\#}
	Las lineas que comienzan con este simbolo $\left(\#\right)$ son procesadas por el preprocesador antes de que el programa se compile.
	
	\subsection{Caracter de escape}
	La diagonal invertda se le conoce como un caracter de escape. Cuando una diagonal invertida se encuentra dentro de una cadena de caracteres, el compilador lo verifica y lo convierte en usa secuencia de escape.
	
	\subsection{Practica}
	
	\begin{itemize}
		\item Ingresar a cdm
		\item entrar a la carpeta utilizando `cd' seguido de la direccion de la carpeta
		\item escribir en la consola ``gcc $($Nombre del archivo$)$.c $-$o $($nombre del archivo$)$.exe"
		\item escribir en la consola `dir'
		\item escribir en la consola `$($nombredel archivo$)$.exe'
	\end{itemize}
	
	\section{indef}
	
	\subsection{Operadores}
	
	\begin{itemize}
		\item $\left(\&\right)$ es un operador de dirección. por lo que indica la variable en la que se va a guardar esa información.
	\end{itemize}
	
	\subsubsection{Operadores Aritmeticos}
	
	\begin{itemize}
		\item suma $\left(+\right)$
		\item resta $\left(-\right)$
		\item multiplicacion $\left(*\right)$
		\item divición $\left(/\right)$
		\item modulo $\left(\%\right)$
	\end{itemize}
	
	\subsubsection{Operadores de igualdad}
	
	\begin{itemize}
		\item ==	`x' es igual que `y'
		\item  !=	`x' es diferente que `y'
	\end{itemize}
	
	\subsubsection{Operadores de relacion}
	
	\begin{itemize}
		\item $>$	`x' es mayor que `y'
		\item $<$	`x' es menor que `y'
		\item $>=$	`x' es mayor o igual que `y'
		\item $<=$	`x' es menor o igual que `y'
	\end{itemize}
	
	\subsection{Operador condicional}
	\begin{itemize}
		\item interrogación $\left(?\right)$ es similar al if-else
	\end{itemize}
	
	
	\subsection{Tipos de variable}
	$($\%$)$ se utiliza para indicar el tipo de variable.
	
	\begin{itemize}
		\item \%d significa que es una variable entera decimal.
		\item \%i significa que es una variable entera.
		\item \%c significa que es un caracter.
		\item \%li significa entero largo.
		\item \%.`numero de decimales'f significa numero real.
		\item \%.`numero de decimales'lf significa real largo.
		\item \%s Significa cadena de caracteres.
	\end{itemize}
	
	\subsection{Variables}
	
	\begin{itemize}
		\item \textbf{char} $($caracter$)$ es de tipo alphanumerico $($\%c$)$
		\item \textbf{int} $($entero$)$ $($\%i$)$
		\item \textbf{short} $($entero corto$)$ $($\%i$)$
		\item \textbf{unsigned int} $($entero positivo$)$ $($\%i$)$
		\item \textbf{long} $($entero largo$)$ $($\%li$)$
		\item \textbf{float} $($real$)$ $($\%f$)$
		\item \textbf{double} $($real con doble de rango$)$ $($\%f$)$
		
	\end{itemize}
	
	\subsection{Condicional}
	
	\begin{itemize}
		\item Se ultiliza if $($condición$)$ 
		
		$\lbrace$
		
		\slash*instruccion*\slash
		
		$\rbrace$
		
		\item else		$\lbrace$
		
		\slash*instruccion*\slash
		
		$\rbrace$ 
	\end{itemize}
	
	\section{Directivas del pre-procesador}
	
	Las librerias del pre-procesador son las que contienen librerias y macros. Todas las directivas comienzan con un simbolo de numeral $(\#)$.
	
	\subsection{\textit{Include}}
	
	\begin{itemize}
		\item \textbf{\#include} $<$stdio.h$>$ 
		
		\textbf{\#include} ``$($nombre del archivo$)$"
	\end{itemize}
	La diferencia entre ambas es la ubicacion en que el pre-procesador busca el archivo a incluir.\\
	
	Si el nombre del archivo se encierra entre comillas, el pre-procesador busca el archivo a incluir en el mismo directorio donde se encuentra el archivo que va a compilarse.\\
	
	Si el nombre del archivo se encierra entre llaves angulares va a buscarlos en los encabezados de la biblioteca estándar.
	
	\begin{itemize}
		\item math.h
		\item stdio.h
		\item stdlib.h
		\item time.h
		\item etc.
	\end{itemize}
	
	\subsection{\textit{Define}}
	La directiva \textbf{\#define} crea constantes simbólicas y macros.\\
	
	Ejemplos:
	
	\begin{itemize}
		\item PI 3.14159
		\item CUBO$($a$)$ a*a*a
	\end{itemize}
	
	\section{Palabras reservadas y conversion de tipos de dato}
	
	\subsection{Palabras reservadas}
	
	\begin{multicols}{5}
		\begin{itemize}
			\item char
			\item int
			\item float
			\item double
			\item long
			\item short
			\item signed
			\item unsigned
			\item void
			\item if
			\item else
			\item do
			\item while
			\item for
			\item switch
			\item case
			\item default
			\item break
			\item continue
			\item goto
			\item struct
			\item union
			\item enum
			\item typedef
			\item return
			\item auto
			\item extern
			\item register
			\item const
			\item static
			\item volatile
			\item sizeof
		\end{itemize}
	\end{multicols}
	
	\subsection{Conversion de tipos de dato}
	Para cambiar de tipo de dato se escribe.\\
	
	...
	
	printf$($``datos$\backslash$n",variable, $($tipo de dato$)$variable, $($tipo de dato$)$variable, ...$)$;
	
	\section{Funciones I}
	El concepto del lenguaje C esta basado en Bloques de construcción, estos bloques se llaman \textit{funciones}. un programa en C es una colección de 1 o mas funciones. En C una función es una subrutina que contiene una o mas sentencias y hace una o mas tareas. En un bien hecho programa en C, cada función hace una sola tarea.\\
	
	En general puedes dar a una función el nombre que quieras, a excepción de \textit{\textbf{main}} que está reservada para la función que inicia la ejecución de tu programa.
	
	\subsection{Función con argumentos}
	Una función argumento es simplemente un valor que es pasado a la función al mismo tiempo que este es llamado.\\
	
	Ejemplo:
	
	\#include $<$stdio.h$>$
	
	void sqr(int x)
	
	$\lbrace$
	
	printf(``\%d cuadrado es \%d$\backslash$n",x,x*x);
	
	$\rbrace$
	
	int main()$\lbrace$
	
	int num;
	
	num=100;
	
	sqr(num);
	
	return 0;
	
	$\rbrace$
	
	\subsection{Funciones que retornan valores}
	\#include $<$stdio.h$>$
	
	int mul(int a, int b)
	
	$\lbrace$
	
	return a*b;
	
	$\rbrace$
	
	int main()
	
	$\lbrace$
	
	int answer;
	
	answer = mul(10,11);
	
	printf(``\%d$\backslash$n",answer);
	
	return 0;
	
	$\rbrace$
	
	\subsection{Forma general de una funcion}
	\textit{return-type function-name} (\textit{parameter list})
	
	$\lbrace$
	
	\textit{body of code}
	
	$\rbrace$
	\\
	
	Para funciones sin parámetros, no habrá lista de ellos.
	
	\section{Ciclos}
	Cuando empezamos a hablar de ciclos hacemos referencia a que tendremos un mejor control del programa. La mayoría de los programas involucran un ciclo donde podemos tomar decisiones pero un poco mas controlado.
	
	\subsection{Ciclo \textit{for}}
	
	Ejemplo:
	
	...
	
	for$($i = 1;i $<$= 10;i++$)$
	
	$\lbrace$
	
	\slash*instrucciones*\slash
	
	$\rbrace$
	
	\subsection{Ciclo \textit{while}}
	Nos permite especificar una acción mientras la condición sea verdadera.\\
	
	\textbf{Ejemplo:\\}
	
	...
	
	int i=1;
	
	while$($i $<$= 10$)$
	
	$\lbrace$
	
	\slash*instrucciones*\slash
	
	i++;
	
	$\rbrace$
	
	
	
	\subsection{Ciclo \textit{Do while}}
	
	\textbf{Ejemplo:\\}
	
	...
	
	int i=1;
	
	do $\lbrace$
	
	\slash*instrucciones*\slash
	
	i++;
	
	$\rbrace$while$($i $<$= 10$)$;
	
	\section{\textit{Switch}}
	Consiste en un grupo de etiquetas \textbf{case} y un caso opcional \textbf{default} que nos va a permitir tener el control dependiendo de los casos que haya en nuestro programa.
	
	\subsection{Etiqueta case}
	Aquí se escribe el nombre del caso; Si es algún carácter debe ir entre comillas o si es un numero puede ser escrito sin ellas.\\
	
	\textbf{Ejemplo:\\}
	
	...
	
	int casos;
	
	printf$($``ingresa un numero\slash n"$)$;
	
	scanf$($``\%i", \&casos$)$;
	
	switch$($casos$)$
	
	$\lbrace$
	
	case 1:
	
	printf$($``elegiste el primer caso\slash n"$)$;
	
	break;\\
	
	case 2:
	
	printf$($``elegiste el segundo caso\slash n"$)$;
	
	break;\\
	
	case 3:
	
	printf$($``elegiste el tercer caso\slash n"$)$;
	
	break;\\
	
	case 4:
	
	printf$($``elegiste el cuarto caso\slash n"$)$;
	
	break;\\
	
	case 5:
	
	printf$($``elegiste el quinto caso\slash n"$)$;
	
	break;\\
	
	default:
	
	printf$($``no encontramos tu caso\slash n"$)$;
	
	break;
	
	$\rbrace$
	
	\section{Arreglos}
	Los arreglos son un conjunto de datos que se van almacenando dentro de una variable. Los arreglos nos permiten guardar muchos de estos datos; en estos casos los arreglos son conocidos como una unidad estática, ya que estos no cambiaran su tamaño durante la ejecución del programa.\\
	
	
	\subsection{Arreglo unidimensional}
	
	\textbf{Ejemplo:\\}
	...
	
	int sizeA;\\
	
	printf$($``tamaño del $\backslash$n"$)$;\\
	
	scanf$($``\%i",\&sizeA$)$;
	
	int age$[$sizeA$]$;
	
	for$($int i = 0;i $<$ sizeA;i++$)$
	
	$\lbrace$
	
	printf$($``ingresa el valor\%$\backslash$n",i+1$)$;
	
	scanf$($``\%i", \&age$[$i$]$$)$;
	
	$\rbrace$
	
	printf$($``los valores del arreglo son:$\backslash$n"$)$;
	
	for $($int i = 0; i $<$ sizeA;i++$)$
	
	$\lbrace$
	
	printf$($``\%i-", age$[$i$]$$)$;
	
	$\rbrace$
	
	printf$($``$\backslash$n"$)$;
	
	\subsection{Strings}
	Por mucho el uso mas común de un arreglo unidimensional es para crear cadenas de caracteres.
	
	La forma mas sencilla de ingresar una cadena desde el teclado es con la funcion \textbf{\textit{gets()}}\\
	
	Para ejemplos de funciones para strings ...$\backslash$learn c$\backslash$c string\_stuff.c
	
	\subsection{Arreglo multidimensional}
	
	\textbf{Ejemplo:\\}
	
	...
	
	\slash*
	
	col..	8	1	2
	
	fila0 	5	3	1
	
	fila1	6	4	2
	
	*\slash
	
	int multi$[$2$]$$[$3$]$ = $\lbrace$$\lbrace$5,3,1$\rbrace$,$\lbrace$6,4,2$\rbrace$$\rbrace$;
	
	printf$($``\%i$\backslash$n",multi$[$0$]$$[$2$]$$)$;\\
	
		Se pueden crear arreglos sin especificar el tamaño, en ese caso C se encarga de crear un arreglo lo suficientemente grande para mantener los datos en el.\\
	
	\textbf{Ejemplo:\\}
	
	char el[ ] = invalid imput;
	
	
	\section{\textit{Break} y \textit{Continue}}
	
	Nos permiten manejar el flujo de nuestro programa como queramos.\\
	
	Estos dos no son considerados como parte de la programación estructurada; sin embargo nos pueden sacar de un gran apuro en ocasiones.
	
	\begin{itemize}
		\item \textbf{break} termina la ejecución de algún ciclo.
		\item \textbf{continue} nos permite seguir ejecutando, pero salta un paso.
	\end{itemize}

	
	\subsection{\textit{Break}}
	
	\textbf{Ejemplo:\\}
	
	...
	
	int num =0;	
	
	while$($num$<$=7$)$
	
	$\lbrace$
	
	if$($num == 2$)$
	
	$\lbrace$
	
	break;
	
	$\rbrace$
	
	printf$($``\%i$\backslash$n",num$)$;
	
	num++;\\
	
	\textbf{En este caso se detiene el programa.}
	
	\subsection{\textit{Continue}}
	Permite ejecutar o continuar nuestro ciclo porque aun hay valores.
	
	Siempre se aumenta el valor antes del if, sino se cicla el programa y se detiene.\\
	
	\textbf{Ejemplo:\\}
	
	...
	
	int num =0;	
	
	while$($num$<$=7$)$
	
	$\lbrace$
	
	if$($num == 2$)$
	
	$\lbrace$
	
	break;
	
	$\rbrace$
	
	printf$($``\%i$\backslash$n",num$)$;
	
	num++;
	
	while$($num$<$=7$)$
	
	$\lbrace$
	
	if$($num == 2$)$
	
	$\lbrace$
	
	continue;
	
	$\rbrace$
	
	printf$($``\%i$\backslash$n",num$)$;\\
	
	\textbf{En este caso se salta el imprimir el numero 2.}
	
	
	\section{Funciones II}
	
	\subsection{Funciones básicas}
	
	
	\textbf{Ejemplo saludo:\\}
	
	...
	
	void saludo$()$
	
	$\lbrace$
	
	printf$($``Hola mundo$\backslash$n"$)$;
	
	return;
	
	$\rbrace$
	
	int main$()$$\lbrace$
	
	saludo$()$;
	
	return 0;
	
	$\rbrace$\\
	
	\textbf{Ejemplo suma:}
	
	int suma$()$;
	
	int main$()$;
	
	$\lbrace$
	
	printf$($``\%i$\backslash$n",suma$())$;
	
	return 0;
	
	$\rbrace$
	
	int suma $()$
	
	$\lbrace$
	
	int num1 =12;
	
	int num2 =4;
	
	int suma = num1 + num2;
	
	return suma;
	
	$\rbrace$
	
	\subsection{funciones de retorno}
	
	\textbf{Ejemplo:\\}
	
	...
	
	int suma$()$;
	
	int num3= 2;
	
	int main$()$;
	
	$\lbrace$
	
	int num1,num2;
	
	printf$($``ingresa el primer valor$\backslash$n"$)$;
	
	scanf$($``\%i",\&num1$)$;
	
	printf$($``ingresa el segundo valor$\backslash$n"$)$;
	
	scanf$($``\%i",\&num2$)$;
	
	printf$($``\%i$\backslash$n",suma$($num1,num2$))$;
	
	return 0;
	
	$\rbrace$
	
	int suma $($int num1, int num2$)$
	
	$\lbrace$
	
	int suma = num1 + num2 + num3;
	
	return suma;
	
	$\rbrace$
	
	\subsection{Funciones re-cursivas}
	
	Son funciones que tienen la propiedad de llamarse a si mismas.\\
	
	\textbf{Ejemplo del factorial de un número:\\}
	
	...
	
	\slash*
	
	5! = 5*4*3*2*1	o	5*4!
	
	4! = 4*3*2*1	o	4*3!
	
	3! = 3*2*1		o	3*2!
	
	2! = 2*1		o	2*1!
	
	1! = 1
	
	0! = 1
	
	*\slash\\
	
	long Factorial$($long numero$)$;
	
	int main$($$)$
	
	$\lbrace$
	
	int numero;
	
	printf$($``ingresa un número$\backslash$n"$)$;
	
	scanf$($``\%i",\&numero$)$;
	
	for $($int i = 0; i $<$= numero; ++i$)$
	
	$\lbrace$
	
	printf$($``\%ld$\backslash$n",Factorial$($i$)$$)$;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$
	
	long Factorial$($long numero$)$
	
	$\lbrace$
	
	if$($numero $<$= 1$)$
	
	$\lbrace$
	
	return 1;
	
	$\rbrace$else$\lbrace$
	
	return$($numero * Factorial$($numero-1$)$$)$;
	
	$\rbrace$
	
	$\rbrace$
	
	\subsection{Forma general de una función}
	
	La forma profecional de una funcion es:\\
	
	\textit{type-specifier function\_name(parameter declarations)}
	
	$\lbrace$
	
	\textit{body of the function}
	
	$\rbrace$\\
	
	El tipo de la función especifica el valor que retorna usando la sentencia \textbf{return}. Puede ser de cualquier tipo valido.La lista de declaración de parámetros es una lista de variables, con sus respectivos tipos y nombres separadas por comas que recibirán los valores de los argumentos cuando al función es llamada. Una función puede no tener parámetros, sin embargo aun son necesarios los paréntesis.
	
	Es importante entender que a diferencia de las variables, los parámetros deben de siempre incluir nombre y tipo. La forma correcta de hacerlo es por ejemplo:\\
	
	f(int x, int y, float z)$\lbrace$$\rbrace$
	
	\subsection{Sentencia return}
	
	La sentencia \textbf{return} tiene 2 importantes usos. Primero causará una salida inmediata de la función actual. Segundo, se puede usar para retornar un valor.
	
	\subsubsection{Retornando desde una función}
	
	Hay 2 maneras en las que una función termina la ejecución y retorna al llamador. La primera manera es cuando la ultima sentencia de la función es ejecutada y se encuentra con el final de la función. Por ejemplo, esta funcion simplemente imprime en sentido contrario en la pantalla:\\
	
	void pr\_reverse(char *s)
	
	$\lbrace$
	
	register int t;
	
	for(t = strlen(s)-1; t $>$ -1; t--) printf(''\%c", s[t]);
	
	$\rbrace$\\
	
	una vez la cadena es desplegada, la función no tiene mas que hacer, entonces regresa a el lugar desde que fue llamada.
	
	la segunda forma una en que funcion puede regresar es desde el uso de la sentencia \textbf{return}. La sentencia \textbf{return} puede ser usado sin algun valor asociado a el. Por ejemplo:\\
	
	void power(int base, int exp)
	
	$\lbrace$
	
	int i;
	
	if(exp < 0) return; /*Cant do negative exponents*/
	
	i = 1;
	
	for( ; exp; exp--) i = base*i;
	
	printf(''the answer is: \%d: ", i);
	
	$\rbrace$
	
	\subsubsection{Retornando un valor}
	
	Para retornar un valor desde una función, deberías seguir la sentencia \textbf{return} con el valor que será retornado. Por ejemplo, esta función retorna el valor máximo de sus 2 argumentos:\\
	
	max(int a, int b)
	
	$\lbrace$
	
	int temp;
	
	if(a $>$ b) temp = a;
	
	else temb = b;
	
	return temp;
	
	$\rbrace$\\
	
	Es posible que una función contenga 2 o mas sentencias \textbf{return}. Mas de un retorno es seguido usado para simplificar y hacer mas eficiente algún algoritmo. Por ejemplo:\\
	
	max(int a, int b)
	
	$\lbrace$
	
	if(a $>$ b) return a;
	
	else return b;
	
	$\rbrace$\\
	
	Es importante tener en cuenta que tener múltiples \textbf{return} puede des-estructurar  una función y hacer que su significado sea confuso. El mejor consejo es usar múltiples \textbf{return} solo cuando contribuyan de manera significativa al rendimiento de la función. todas las funciones, excepto las tipo \textbf{void} retornan un valor. Este valor está explícitamente especificada por la sentencia \textbf{return}.\\
	
	Como todas las funciones, excepto las tipo \textbf{void} retornan valores, cuando escribes programas, tus funciones generalmente serán de 3 tipos. El primero es simplemente computacional. Está específicamente diseñado para realizar operaciones en sus argumentos y retornan un valor basado en esa operación, en esencia es una función ''pura". Ejemplos de esto son la función \textbf{sqrt()} y \textbf{sin()}, que retornan el un numero raiz cuadrada y seno, respectivamente.
	
	El segundo tipo de funciones manipulan información y retorna un valor indicando el éxito o fallo de esa manipulación. Un ejemplo es \textbf{fwrite()}, que es usado para escribir información a un archivo de disco. Si la operación de escritura es exitosa \textbf{fwrite()} retorna el numero de cosas pediste sean escritos; cualquier otro valor, indica que un error ha ocurrido.
	
	El ultimo tipo de función no tiene un tipo explicito de valor de retorno. en esencia, la función es estrictamente procedimental y no produce valor. por turbias razones históricas, muchas veces funciones que realmente no producen un resultado interesante, retornan algo igualmente. Por ejemplo, \textbf{printf()} retorna el numero de caracteres escritos; seria muy inusual encontrar un programa que de hecho revise esto. Por lo tanto , aunque todas la funciones (excepto aquellas tipo \textbf{void}) retornan algo, no necesariamente tienes que utilizarlos para algo.
	
	\subsection{Funciones retornando valores no enteros}
	
	Cuando es necesario retornar diferentes tipos de datos a \textbf{int}se requiere un proceso de 2 pasos. Primero declarar la función; segundo, se le debe decir al compilador el tipo de la función antes de su primera llamada.
	
	Las funciones pueden ser declaradas para retornar cualquier tipo de dato valido en C. El método de declaración es similar a la de variables: el tipo especificado precede el nombre de la función, el especificador de tipo le dice al compilador que tipo de dato la función retorna. La mejor manera de informar al compilador sobre el tipo de retorno de una función es el usar un prototipo de función\\
	
	\subsubsection{Usando funciones prototipo}
	
	Una función prototipo realiza 2 tareas. Primero identifica el tipo de retorno de una función. Segundo especifica en tipo y numero de argumento que una función recibe. Tiene la siguiente forma general:\\
	
	\textit{type function-name(parameter list);}\\
	
	El parámetro por convención va cerca de la parte superior del programa o en un header file y debe ir antes de cualquier llamada se hace de la función.
	
	\subsubsection{Retornando punteros}
	
	Como cada tipo de dato puede tener una longitud diferente, el compilador debe saber que tipo de dato el apuntador está apuntando para apuntar al siguiente dato. Por lo tanto, una función que retorna un puntero debe ser declarado como ello. Por ejemplo aquí hay una función que retorna un puntero a una cadena en el lugar donde un carácter que coincide es encontrado:\\
	
	...$\backslash$learn c$\backslash$c pointer\_return.c\\
	
	\subsubsection{Funciones de tipo void}
	
	cuando una función no retorna un valor, puede ser declarada como tipo \textbf{void}. hacerlo evita su uso en cualquier expresión y ayuda a evitar errores accidentales. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c function\_void.c\\
	
	\subsection{Mas en prototipos}
	
	\subsubsection{Desajustes de argumento}
	
	Ademas de decir al compilador sobre el tipo de retorno de una función, un prototipo  también previene a la función de ser llamada con un tipo incorrecto o numero de argumentos. aunque C automáticamente convertirá el tipo de un argumento a el tipo del parámetro que está recibiendo, algunos tipos de conversión son simplemente ilegales. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c illegal\_argument.c\\
	
	Ademas, el usar prototipos de función, ayuda a encontrar bugs antes de que ocurra, reviniendo a una función el ser llamada con argumentos inválidos, también ayuda a verificar que tu programa trabaja correctamente, no permitiendo llamar funciones con el numero equivocado de argumentos.\\
	
	\subsubsection{Archivos de cabecera }
	
	Los archivos de cabecera contienen 2 principales cosas: ciertas definiciones usadas por las funciones y los prototipos de las funciones estándar relacionadas con el archivo de cabecera.
	
	\subsubsection{Forma general prototipos de función}
	
	La forma general de los prototipos de función es:\\
	
	\textit{tipo nombre(parametros);}\\
	
	En C es posible escribir un prototipo parcial de la funcion, evitando escribir los parametros, sin embargo esto no es valido para C++, por lo que se recomienda siempre evitar escribir un prototipo parcial de la funcion.
	
	\subsection{Reglas de alcance}
	
	Las reglas de alcance de un lenguaje son las reglas que gobiernan ya sea una pieza de código que sabe o tiene acceso a otra pieza de código o dato.
	
	En C, cada función es un bloque discreto de código. El código de una función es privado a otra función y no puede ser accesado por alguna sentencia en cualquier otra función, excepto por una llamada de esa función. El código que compromete el cuerpo de una función está escondido del resto del programa y a no ser que use variables o datos globales, no puede afectar ni ser afectado por otras partes del programa, excepto a la especificación de tu programa. Visto de otra manera, el código y los datos que están definidos en una función, no pude interactuar con el código o los datos definidos en otra función, a no ser sea explícitamente especificado, porque las 2 funciones tienen diferente alcance.
	
	Hay 3 tipos de variables: \textit{variables locales, parámetros formales} y \textit{variables globales}. Las reglas de alcance gobiernan como cada una de estas puede ser accesado por otras partes de tu programa u establece.
	
	\subsubsection{Variables locales}
	
	Las variables que son declaradas dentro de una función son llamadas \textit{variables locales}. Una variable puede ser declarada dentro de cualquier bloque de código y ser local en el. Lo mas importante de entender sobre variables locales es que exixten solo mientras el bloque de cofigo en el que fueron declarados se extá ejecutando. el bloque de codigo mas comun en el que las variables locales son declaradas es la funcion. Pir ejemplo:\\
	
	...$\backslash$learn c$\backslash$c local\_variables.c\\
	
	\subsubsection{Parámetros formales}
	
	Si una función usa argumentos, entonces deberían declararse variables que que acepten los valores de esos argumentos, estas se conforman como cualquier otra variable local, esto son los parámetros formales.
	
	\subsubsection{Variables globales}
	
	Las variables locales son conocidas durante toda la ejecución del programa, por lo que se pueden utilizar en cualquier bloque de código en el programa, como consecuencia de esto, mantienen su valor mientras no se le hagan asignaciones.
	
	Cuando una variable global y una variable local tienen el mismo nombre, todas las referencias a una variable con ese nombre dentro de la función donde se declara la variable local, se referirán a esa variable local. Ademas no afectará a la variable local, esto puede ser beneficioso, sin embargo puede hacer que tu programa actúe extraño aunque parezca estar bien.
	
	Deberías evitar usar variables globales innecesarias por 3 razones:
	
	\begin{itemize}
		\item Toman memora todo el tiempo en que tu programa se ejecuta, no solo cuando se necesita.
		\item Usando un global donde una variable local hará a una funcion menos general, pues depende en algo que se define fuera de si.
		\item Usar un gran numero de variables globales pueden llevar al programa errores por desconocidos y desagradables efectos secundarios.
	\end{itemize}
	
	Esta ultima razón esta evidenciada en BASIC, donde todas las variables son globales. Un grave problema desarrollando largos programas es accidentalmente cambiando el valor de una variable porque fue utilizada demasiadas variables globales en tu programa.
	
	Uno de los principales puntos de un lenguaje estructurado es la compartimentación de código y datos. En C compartimentación es lograda a través de el uso de funciones y variables locales. Por ejemplo:
	
	\begin{multicols}{2}
		\begin{itemize}
			\item Especifico
			
			int x, y;
			
			mul()

			$\lbrace$
			
			return (x*y);
			
			$\rbrace$
			
			\item General
			
			mul(int x, int y)
			
			$\lbrace$
			
			return (x*y);
			
			$\rbrace$
		\end{itemize}
	\end{multicols}
	
	Ambas funciones retornarán el producto de variables \textbf{x} y \textbf{y}. sin embargo, la versión generalizada o \textit{parametrizada} puede ser utilizada para retornar el producto de cualquier par de numeros, mientras que la version especifica puede ser utilizada para encontrar solo el producto de las variables globales \textbf{x} y \textbf{y}.
	
	\subsection{Funciones, parámetros y argumentos}
	
	\subsubsection{Llamada por valor, llamada por referencia}
	
	En general, subrutinas pueden ser pasados por argumentos en una de dos maneras. El primer método es llamado \textit{llamada por valor}. Este método copia el valor de un argumento en el parámetro formal de la subrutina. Por lo tanto, cambios hachos en el parámetro de la subrutina no tiene efectos en la variable usada para llamarla.
	
	\textit{Llamada por referencia} es la segunda manera en que a una subrutina se le puede pasar un argumento, la dirección de un argumento es copiado en el parámetro. Dentro de la subrutina, la dirección es usada para acceder al propio argumento usado en la llamada. esto significa que los cambios hechos a el parámetro afectara a la variable usada para llamar la rutina.
	
	\subsubsection{Creando una llamada por referencia}
	
	Aun cuando la convención en C para pasar parámetros es la llamada por valor, es posible crear una llamada por referencia pasando un puntero como argumento. Esto hace posible cambiar el valor de el argumento fuera de la función. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c pointers\_everywhere.c\\
	
	...$\backslash$learn c$\backslash$c llamada\_referencia.c\\
	
	En este punto deberías de haber podido entender porque tienes que poner \textbf{\&} enfrente de los argumentos para \textbf{scanf()}. De hecho lo que estas haciendo es pasar su dirección para que la variable llamada pueda ser modificada.\\
	
	\subsubsection{Llamado funciones con arreglos}
	
	Cuando un arreglo es pasado como argumento de una función, solo la dirección del arreglo se pasa, no se copia todo el arreglo. Cuando tu llamas una función con un arreglo nombre, un puntero a el primer elemento del arreglo se pasa a la función (recuerda, en C el nombre de un arreglo sin algún indice es un puntero al primer elemento de ese arreglo.) Esto significa que la declaración del parámetro debe ser compatible con un tipo puntero. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c pointer\_return.c\\
	
	...$\backslash$learn c$\backslash$c llamada\_arreglo.c\\
	
	Esto está permitido porque cualquier puntero puede ser indexado como si fuera un arreglo.
	
	Hay que reconocer que los 3 métodos de declarar un parámetro arreglo llevan al mismo resultado: un puntero.
	
	Un arreglo elemento usado como un argumento e tratado como cualquier otra variable. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c array\_element\_pointer.c\\
	
	\subsection{Argumentos de main}
	
	La forma general de pasar información a \textbf{main()} es a través de el uso de argumentos de la linea de comandos. Esto es la información que va después del nombre del programa(y su extensión).
	
	Hay 3 solamente maneras de construir argumentos a main. Los primeros 2 son \textbf{argc} y \textbf{argv} son usados para recibir argumentos en linea de comandos. El tercero es \textbf{env} y es utilizado para accesar a los parámetros activos ambientales DOS en el momento en que el programa comienza su ejecución.
	
	\textbf{argc()} almacena el numero de argumentos en la linea de comandos y es un entero, siempre será al menos 1, Porque el nombre del programa califica como primer argumento. El parametro \textbf{argv} es un puntero a un arreglo de cadenas. Todos los argumentos de linea de comandos son cadenas, cualquier numero tendrá que ser convertido por el programa al formato correcto. Por ejemplo:\\
	 
	...$\backslash$learn c$\backslash$c main\_argument.c\\
	
	Cada argumento de comando de linea debería ser separado por un espacio o un tab, comas, semi-columnas y similares no son considerados separadores.
	
	Se pueden ejecutar series de comandos DOS en la linea de comando. Esto se logra usando la función de librería \textbf{system()}. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c main\_arg\_system.c\\
	
	El parámetro \textbf{env} es declarado igual que el parametro\textbf{argv}. Este es un puntero a un arreglo de cadenas que contienen las configuraciones ambientales.
	
	\subsection{Retornando valores desde main()}
	
	Cuando retornas una valor entero desde \textbf{main()} se pasa al proceso de llamado, usualmente al sistema operativo. Para DOS y OS/2, un retorno de valor 0 indica una terminación exitosa del programa, cualquier otro valor indica que el programa termino debido a un error. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c return\_error\_main.c\\
	
	\subsection{recursion}
	
	En C y C++, las funciones pueden llamarse a si mismo. una función es re-cursiva si un estatuto en el cuerpo de la función se llama a si misma. cuando una función se llama a si mismo, nuevas variables locales y parámetros son guardados en el stack y el código de la función es ejecutada con estas nuevas variables desde el inicio. Una llamada re-cursiva no hace una copia de la función, solo se hacen nuevas variables y parámetros.
	
	la mayoría de las rutinas re-cursivas, no reducen significativamente el tamaño del código y el almacenamientos de variables, ademas de que la mayoría suelen ser un poco mas lentas que sus equivalentes iterativos, por la re-llamada de la función, sin embargo no es notable en la mayoría de los casos. Algunas funciones pueden causar \textit{stack overrun}, pero esto no es usual que pase yque cause un crash.
	
	la principal ventaja  de funciones re-cursivas es que pueden usarse para crear mal limpias y simples versiones de varios algoritmos que sus hermanos iterativos. por ejemplo el algoritmo de ordenamiento \textit{QuickSort}  es difícil de implementar de forma iterativa. también algunos problemas relacionados con \textit{AI} tienden a llevar a si mismos a soluciones re-cursiva. Finalmente, algunas personas suelen pensar que las formas re-cursivas son mas fáciles. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c recursivas.c
	
	\subsection{problemas de implementación}
	
	\subsubsection{parámetros y funciones de propósito general}
	
	Una función de propósito general es la que se utiliza en una amplia variedad de situaciones. Típicamente no deberías basar funciones de propósito general en datos globales, Es mucho mejor que cualquier cosa pasar toda la información una función necesita por sus parámetros.\\
	
	\subsection{Eficiencia}
	
	En ciertas especializaciones aplicaciones, quizá necesites eliminar una función y remplazarlo con \textit{codigo in-line}. Esto es equivalente a una sentencia de una función usada sin llamar a esa función.
	
	Existen 2 rezones de porque código in-line es mas rápido qe una función llamada. Primero, una instrucción llamada toma tiempo para ejecutar. Segundo, si hay argumentos para pasar, estos tienen que ser colocados en el stack, que también toma tiempo. Para la mayoría de aplicaciones, esto es un incremento muy bajo, sin embargo, pero cuando es para muy importantes tareas contra el tiempo es critico.
	
	\section{Apuntadores}
	
	\subsection{Conceptos básicos}
	Los apuntadores son variables cuyos valores son direcciones de memoria. por lo general una variable contiene directamente un valor en especifico; por otro lado un apuntador contiene la dirección de una variable que contiene un valor especifico.\\
	
	\textbf{Una variable apuntador se define como:\\}
	
	...
	
	int a = 2;
	
	int *apt = \&a;\\
	
	\textbf{Se imprime como:\\}
	
	...
	
	printf$($``\%i$\backslash$n",*apt$)$;\\
	
	\textbf{Para imprimir la dirección de memoria como un numero hexadecimal se hace:\\}
	
	...
	
	printf$($``\%p$\backslash$n",apt$)$;\\
	
	
	\subsubsection{Aritmética de apuntadores}
	
	Solo hay 2 tipos de operadores que deberian ser usados con apuntadores suma y resta de enteros. Cada incremento/decremento en un apuntador se guia por:
	\\
	
	ptr = ptr + (sizeof(tipo\_de\_dato) * n)
	
	\subsection{Apuntadores y arreglos}
	
	Existe una relación cercana entre arreglos y apuntadores, considera este fragmento.\\
	
	char str[80], *pl;\\
	
	pl = str;\\
	
	Aquí \textbf{pl} ha sido asignado a la dirección del primer elemento del arreglo \textbf{str}. otra forma de escribir esto es:\\
	
	pl = \&str[0];\\
	
	sin embargo  esta es considerada una forma pobre por mayor parte de los programadores de C, si quisieras accesar al quinto elemento en \textbf{str} podrias escribir:\
	
	str[4]\\
	
	o\\
	
	*(pl+4)\\
	
	Ambas maneras regresarán el quinto elemento.\\
	
	En C es posible indexar un apuntador como si fuera un arreglo. Esto hace mas evidente la cercana relación entre arreglos y apuntadores. Por ejemplo, este fragmento es completamente valido:\\
	
	int i[5] = $\lbrace$1, 2, 3, 4, 5$\rbrace$;
	
	int *p, t;\\
	
	p = i;\\
	
	for (t = 0; t $<$ 5; ++t)
	
	$\lbrace$
	
		printf("\%d$\backslash$n", p[t]);
		
	$\rbrace$\\
	
	En C, p[t] es idéntico a (p+t)\\
	
	Hasta ahora,  los ejemplos han estado concentrados en asignar la dirección de el inicio de un arreglo a un apuntador. Sin embargo, es posible asignar la dirección de un elemento especifico de un arreglo aplicando el \textbf{\&} a un arreglo indexado, por ejemplo este fragmento pone la dirección del tercer elemento de \textbf{x} en \textbf{p}:\\
	
	p = \&x[2];\\
	
	Un lugar donde esta practica es especialmente útil es en encontrar una sub-cadena. Por ejemplo, este programa imprimirá desde que el primer espacio es encontrado. ...$\backslash$learn c$\backslash$c array\_address.c\\
	
	\subsubsection{Arreglo de apuntadores}
	
	Apuntadores pueden ser arreglados así como harías con cualquier otro tipo de datos. La declaración de  un arreglo de punteros \textbf{int}  de tamaño 10 es:\\
	
	int *x[10];\\
	
	Para asignar la dirección de una variable entero a el tercer elemento de un arreglo puntero, escribirías\\
	
	x[2] = \&var;\\
	
	Para encontrar el valor de \textbf{var}, escribirías\\
	
	*x[2]\\
	
	un uso común de los arreglos punteros es el mantener punteros de mensajes de error. puedes crear una funcion que imprima un mensaje. Por ejemplo:\\
	
	char *err[ ] = $\lbrace$
	
	''cannot open fill$\backslash$n",
	
	''read error$\backslash$n",
	
	"write error$\backslash$n",
	
	"media failure$\backslash$n"
	
	$\rbrace$;\\
	
	void serror(int num)
	
	$\lbrace$
	
	printf ("\%s", err[num]);
	
	$\rbrace$\\
	
	Como puedes ver, \textbf{printf()} está dentro de \textbf{serror()} con un apuntador carácter, el cual apunta a uno de los varios mensajes de error indexados por el numero de error pasado de una función. Por ejemplo, si a \textbf{num} se le pasa 2, entonces el mensaje \textbf{write error} es desplegado.
	
	Otra interesante aplicación para los arreglos de punteros inicializados usa la función \textbf{system()} de C, que le permite a tu programa mandar un comando al sistema operativo. la llamada de \textbf{system()} tiene esta forma general\\
	
	\textbf{system}(''\textit{command}");\\
	
	Donde \textit{command} es el comando de sistema operativo a ejecutar. Por ejemplo, asumiendo un ambiente DOS, esta sentencia hace que el directorio default sea desplegado.\\
	
	system(''\textit{DIR}");\\
	
	El siguiente programa implementa un muy pequeño menu-driven user interface que puede ejecutar cuatro DOS comandos: DIR, CHKDSK, TIME Y DATE.\\
	
	...$\backslash$learn c$\backslash$c array\_of\_pointers.c\\
	
	Para una mejor ilustración de la inter-coneccion entre arreglos y punteros, desarrollaremos un simple programa traductor ingles a alemán.\\
	
	...$\backslash$learn c$\backslash$c english\_german.c\\
	
	El arreglo \textbf{trans} es de hecho un arreglo de punteros de las cadenas bajo su declaración.\\
	
	\subsection{Punteros a punteros}
	
	El concepto de arreglos de punteros es directo porque los indices mantienen su significado claro. Sin embargo, punteros a punteros pueden ser muy confusos.\\
	
	Un puntero a un puntero es una forma de \textit{indireccion multiple}, o cadena de punteros. Como puedes ver en la figura 8-3. (Using turbo C++, pg. 207), en el caso de un puntero normal, el valor de el puntero es la dirección de la variable que contiene el valor designado. En el caso de un puntero a un puntero el primer puntero contiene la dirección de el segundo puntero, el cual apunta a la variable, la cual contiene el valor designado.
	
	Indireccion múltiple puede ser llevada acabo en a manera deseada, pero hay algunos casos donde mas de un puntero a un puntero es necesario, o de hecho deseable usarlo. Excesiva indireccion es difícil de seguir y propensa a errores (no confundas múltiple indireccion ncon \textit{listas linkeadas} que se utilizan en base de datos y similares).\\
	
	una variable que es un puntero a un puntero debería ser declarado como ello. Esto se hace poniendo un asterisco adicional en frente de su nombre. Por ejemplo:\\
	
	float **newbalance;\\
	
	Es importante entender que \textbf{newbalance} no es un puntero a un floating-point number, sino un puntero a un puntero float.
	
	para acceder al valor apuntado apuntado indirectamente atravez de un puntero de un puntero, el operador asterisco debe ser aplicado dos veces como se ve en este pequeño ejemplo.\\
	
	...$\backslash$learn c$\backslash$c pointed\_pointer.c\\
	
	\subsection{Inicializar punteros}
	
	Después de que un puntero es declarado pero antes de asignarle un valor contendrá un valor indefinido. Si intentas usar un puntero antes de darle un valor probablemente crashearas no solo tu programa, sino también tu sistema operativo.\\
	
	por convención un puntero que apunta a nada debería de darse le un valor null, para dignificar que apunta a nada. Sin embargo, solo por que un puntero tenga un valor null no implica que sea ''seguro", si corres un puntero con valor nulo, aun corres el riesgo de crashear tu programa y el sistema operativo.
	
	porque un puntero nulo es asumido que permanecerá desusado, puedes usarlo para hacer muchas de tus rutinas de punteros mas fáciles de programar y mas eficientes. Por ejemplo, puedes usar un puntero nulo para marcar el final de un arreglo de punteros. si esto se hace, una rutina que accese ese arreglo sabrá que se ha alcanzado el final cuando el valor nulo es encontrado. Ejemplo:\\
	
	for(t = 0; p[t]; ++t)
	
	$\lbrace$
	
	if(!strcmp(p[t], name)) break;
	
	$\rbrace$\\
	
	Este es un ejemplo de una practica muy común en programación profesional de C. Otra variacion en este tema es el siguiente ejemplo de la declaracion de una cadena:\\
	
	char *p = ''hello world$\backslash$n";\\
	
	como puedes ver el puntero \textbf{p} no es un arreglo. La razon que este tipo de inicializacion funciona, tiene que ver con como C maneja cadenas constantes, los compiladores de C crean una tabla de cadenas donde  guardan las cadenas constantes usadas por el programa. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c null\_pointer.c\\
	
	sin embargo, tu programa no debe hacer asignaciones a la tabla de cadenas atraves de \textbf{p}, pues tu programa puede corromperse (NO ASIGNES VALORES NUEVOS AHI).\\
	
	\subsection{Problemas con punteros}
	
	Nada te traerá mas problemas que un puntero ''salvaje". punteros son un milagro mixto. ellos dan un tremendo poder y son necesarios para muchos programas, pero cuando un puntero accidentalmente contiene un valor equivocado, puede ser el bug mas difícil de encontrar.
	
	Un bug de puntero erróneo es difícil de encontrar porque el puntero en si no es el problema; el problema es que cada vez que intentas perforar una operación usándola, estas leyendo o escribiendo en una pieza desconocida de la memoria. Si tu lees de ella, lo peor que puede pasar el que tengas basura. Sin embargo, si escribes en ella puedes estar escribiendo sobre otras piezas de tu código o datos. Esto puede no mostrarse hasta después en la ejecución del programa y puede dirigirte a buscar el bug en el lugar equivocado. Esto puede dar muy poca a nada de evidencia sugiriendo que el puntero es el problema. Este tipo de bug ha causado a programadores perder tiempo y sueño.
	
	Porque errores de punteros son una pesadilla, deberías dar lo mejor por nunca generar uno. Para hacer la asignacion de una variable \textbf{x} a un puntero \textbf{p} debe de ser:\\
	
	p = \&x;\\
	
	o\\
	
	int *p = \&x\\
	
	Y se imprime:
	
	printf("\%d", *x);\\
	
	Si es un arreglo puede ser:
	
	p = i;,\\
	
	o\\
	
	int *p = i;\\
	
	o\\
	
	int *p = \&i[0];\\
	
	Y se imprime:
	
	printf("\%d", *x);\\
	
	Pero si es una cadena puede ser:
	
	printf(p);\\
	
	o\\
	
	printf("\%s", p);\\
	
	No evites utilizar punteros solo por que cuando son manejadas incorrectamente pueden causar bugs muy engañosos. Deberías ser cuidadoso y asegurarte de que sabes donde cada puntero apunta antes de usarlo.\\
	
	

	\subsection{Llamadas por referencia}
	Existen 2 maneras de pasar argumentos a una función.
	\begin{itemize}
		\item llamadas por valor
		\item llamadas por referencia
	\end{itemize}
	
	Hasta ahora hemos utilizado las funciones y hemos pasado los argumentos por valor, pero muchas funciones requieren la capacidad de modificar una o mas variables en una sola llamada de la función. En ese caso podemos evitar sobrecargas de pasar objetos por valor.
	
	Las sobrecargas en si es hacer copias del objeto o de nuestra variable.\\
	
	La diferencia es que las funciones se definen de tipo \textbf{void}, las cuales no están obligadas a devolver un valor.\\
	
	\textbf{Ejemplo:\\}
	
	...
	
	void cubo$($int *n$)$;
	
	int main$()$
	
	$\lbrace$
	
	int num = 5;
	
	printf$($``El valor original es: \%i$\backslash$n",num$)$;
	
	cubo$($\&num$)$;
	
	printf$($``El nuevo valor es: \%i$\backslash$n",num$)$;
	
	return 0;
	
	$\rbrace$
	
	void cubo$($int *n$)$
	
	$\lbrace$
	
	*n = *n * *n * *n;
	
	$\rbrace$
	
	\section{I/O y Archivos}
	
	\subsection{Streams y archivos}
	
	El sistema de C I/O provee un nivel de abstracción entre el programador y el artefacto usado. Esta abstracción es llamada \textit{stram} y el propio dispositivo es llamado \textit{archivo}. Es importante conocer como ellos interactuan.
	
	\subsection{Streams}
	
	El ANSI C sistema de archivos, está diseñado para trabajar en una gran variedad de dispositivos, incluyendo terminal, disk driver y tape drives. Aunque cada dispositivo es muy diferente, el ANSI C sistema de archivos, transforma cada uno en un dispositivo lógico llamado stream. todos los strams son similares en su comportamiento. Porque strams son ampliamente independientes de los dispositivos, la misma funcion que escribe en un archivo en disco puede también escribir en la consola, Existen 2 tipos de streams: texto y binario.
	
	\subsubsection{Streams de texto}
	
	Es una secuencia de caracteres. En un stream de texto, ciertos caracteres de traducción pueden ocurrir como requeridos por el ambiente anfitrión. Por ejemplo, una nueva linea puede ser convertida, de manera que el numero de caracteres escritos o leídos son necesariamente los mismos que encontramos en el dispositivo externo.
	
	\subsubsection{Streams binarios}
	
	Es una secuencia de bytes que tiene una correspondencia 1-a-1 a eso encontrado en el dispositivo externo. Eso es que no se hace traducción de caracteres. El numero de bytes escritos o leídos, será el mismo que el numero de bytes encontrados en el dispositivo externo. Sin embargo, streams binarios pueden estar repletos de bytes nulos para que llene un sector de un disco
	
	\subsubsection{Archivos}
	
	En C, un archivo es un concepto lógico que puede se aplicado a todo desde archivos de discos a terminales. Un stream está asociado con un especifico archivo, haciendo una operación abrir. Cuando se abre un archivo, información puede ser intercambiada entre archivo y programa.
	
	no todos los archivos tienen las mismas capacidades. Por ejemplo, un archivo de disco puede soportar acceso aleatorio mientras un disco de cinta no puede. Esto marca algo muy importante del sistema de C I/O: todos los streams son iguales, pero no todos los archivos son iguales.
	
	Si el archivo puede soportar acceso aleatorio (a veces llamado \textit{solicitud de posición}), entonces abrir ese archivo también inicia el \textit{indicador de posición de archivo} para empezar del archivo.
	
	\subsection{Conceptual contra real}
	
	Tan lejos como le concierne al programador, todo I/O pasa a traves de streams, que son las secuencias de caracteres. Todos los streams son lo mismo. el sistema de archivos une un stream con un archivo. En C, un archivo es cualquier dispositivo externo, capaz de I/O.
	
	\subsection{Consola I/O}
	
	Esto se refiere a operaciones que ocurren en el teclado y monitor de tu computadora.
	
	\subsubsection{Leyendo y escribiendo caracteres}
	
	Las funciones de consola I/O mas simples son \textbf{getche()}, que lee un caracter desde el teclado y \textbf{putchar()}, que imprime un caracter en la pantalla. La funcion \textbf{getche()} espera hasta que una tecla es presionada y entonces retorna un valor. La tecla presionada es ``echoed" a la pantalla automaticamente. La funcion \textbf{putchar()} escribirá un caracter argummento a la pantalla en la posicion actual del cursor. El prototipo de \textbf{putchar()} y \textbf{getche()} es este.\\
	
	int getche(void);\\
	
	int putchar(int c);\\
	
	...$\backslash$learn c$\backslash$c	putchar.c
	
	El archivo de cabecera de \textbf{getche()} es CONIO.H y el de \textbf{putchar()} es STDIO.H, El archivo de cabecera de la función \textbf{islower()} es CTYPE.H. Ejemplo:\\
	
	...$\backslash$learn c$\backslash$c case\_switcher.c\\
	
	Hay 2 importantes variaciones en \textbf{getche()}. El primero es \textbf{getchar()}, que es la función original basado en UNIX de ingresar caracteres. El problema con \textbf{getchar()} es que se cicla hasta que se ingresa un carácter, por ello su uso no es recomendado.
	
	la segunda y mas útil variación de \textbf{getche()} es \textbf{getch()}, que opera precisamente como \textbf{getche()}, excepto que el carácter no es impreso en la pantalla.
	
	\subsubsection{Leyendo y escribiendo cadenas}
	
	El siguiente paso en términos de complejidad y poder, están las funciones \textbf{gets()} y \textbf{puts()}. Estos permiten leer y escribir cadenas de caracteres en la consola.
	
	La función \textbf{gets()} lee una cadena de caracteres entradas y las escribe en la direccion apuntada por su argumento apuntador. El prototipo de \textbf{gets()} es:\\
	
	char *gets(char *s);\\
	
	La función gets retorna un puntero de \textbf{s}
	
	la función \textbf{puts()} escribe el argumento de su cadena en pantalla seguido por  una nueva linea. Su prototipo es:\\
	
	int puts(char *s);\\
	
	Reconoce los mismos códigos backslash como \textbf{printf()} como ''$\backslash$t" para tab. una llamada de \textbf{puts()} requiere mucho menos sobrecarga que la misma llamada de \textbf{printf()} porque \textbf{puts()} solo puede imprimir una cadena de caracteres- no puede imprimir números o hacer conversiones de formato. Por lo tanto la funcion \textbf{puts()} toma menos espacio y corre mas rapido que \textbf{printf()}. Por ejemplo:\\
	
	puts(''hello");\\
	
	La funcion \textbf{puts()} usa el archivo de cabecera STDIO.H
	
	\subsection{Consola I/O formateada}
	
	El prototipo de \textbf{printf()} es:\\
	
	int printf(char *control\_string,...)\\
	
	Notese los 3 puntos En el prototipo de \textbf{printf()}. cuando una función puede tomar un numero variable de argumentos, entonces su prototipo usa los tres puntos para especificar esto.
	
	En la función \textbf{scanf()} las cadenas serán leídos en arreglos de caracteres, y el nombre de un arreglo sin algún indice, es la dirección del primer elemento del arreglo. Entonces para leer una cadena en la dirección del arreglo de la caracteres, podrías usar lo siguiente:\\
	
	scanf(''\%s", address);\\
	
	En este caso \textbf{address} es ya un puntero, y no necesita ser precedido por el operador \&.
	
	Los datos de entrada deben ser separados por espacios, tabs o nuevas lineas. puntuación como comas, semi-columnas y similares, no cuentan como separadores. Esto significa que:\\
	
	scanf(''\%d\%d", \&r, \&c);\\
	
	Aceptará una entrada de 10 20, pero fallará con 10,20\\
	
	La función \textbf{scanf()} incluye un a característica muy poderosa llamada \textit{scanset}. un scanset define una lista de caracteres que serán alineados por \textbf{scanf()}. La función \textbf{scanf()} seguirá leyendo caracteres mientras estén en el scanset. Tan pronto como un carácter de entrada no se alinea con alguno del scanset, \textbf{scanf()} se mueve hacia el siguiente. Un scanset es se define poniendo una lista de los caracteres que quieras escanear dentro de paréntesis cuadrados. El inicio de los paréntesis cuadrados tiene como prefijo un signo de porcentaje, por ejemplo este scanset le dice a \textbf{scanf()} leer solo los dígitos desde 0 hasta 9:\\
	
	\%[1234567890] Esta declaración solo permitirá que esta cadena sea leída por la variable indicada\\
	
	Puedes especificar un rango dentro de una scanset usando un guion medio. por ejemplo:\\
	
	\%[A-Z]\\
	
	Esto le dice a \textbf{scanf()} que solo acepte caracteres desde A hasta Z. Ademas se puede especificar mas de un rango en el scanset. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c scanf\_range.c\\
	
	Algo importante de recordar es que scanset es case-sensitive, entonces si quieres poner mayúsculas y minúsculas individualmente.
	
	\subsection{El sistema ANSI I/O}
	
	El sistema ANSI I/O está compuesta de varias funciones interrelacionadas. Estas funciones requieren que el archivo de cabecera STDIO.H son incluidas por cualquier programa en donde son usadas.
	
	\subsubsection{El apuntador de archivo}
	
	Un común hilo que ata el sistema ANSI C I/O es el apuntador de archivo. Un apuntador e archivo es un puntero a información que define varias cosas sobre el archivo, incluyendo su nombre, estado y actual posición. En esencia, un archivo puntero identifica un archivo en disco duro y es usado por un stream asociado con el para la operación directa de funciones ANSI C I/O. un archivo puntero es un puntero de variable tipo \textbf{FILE}, que esta definido en STDIO.H. Para leer o escribir archivos, tu programa necesitará usar punteros de archivo. Para obtener variables puntero de archivo se utiliza una sentencia como la siguiente:\\
	
	FILE *fp:\\
	
	\begin{tabular}{l|l}
		\textbf{Function} & \textbf{Operation}\\
		\hline
		fopen() & Opens a stream\\[.7ex]
		fclose() & Closes a stream\\[.7ex]
		putc() & Writes a character on a stream\\[.7ex]
		getc() & Reads a character from a stream\\[.7ex]
		fseek() & Seeks to the specified sbyte in a stream\\[.7ex]
		fprintf() & Is to stream what \textbf{printf()} is to the console\\[.7ex]
		fscanf() & Is to stream what \textbf{scanf()} is to the console\\[.7ex]
		feof() & Returns true if the end of the file is reached\\[.7ex]
		ferror() & Returns true if an error has ocurred\\[.7ex]
		fread() & Reads a block of data from a stream\\[.7ex]
		fwrite() & Writes a block of data from a stream\\[.7ex]
		rewind() & Resets the file position locator to the begining of the file\\[.7ex]
		remove() & Erates a file
	\end{tabular}
	
	\subsubsection{Abriendo un archivo}
	
	La funcion \textbf{fopen()} sirve a dos propósitos. Primero abre un stream para usarlo y lo conecta a un archivo con ese stream. Segundo, retorna el archivo puntero asociado con ese archivo. Mas comunmenteel archivo es de disco. la funcion \textbf{fopen()} tiene este prototipo:\\
	
	FILE *fopen(char *nombre-archivo, char *modo);\\
	
	Donde \textit{modo} es una cadena conteniendo abierto el estado deseado. El nombre de archivo debe ser una cadena de caracteres que comprometa un nombre de archivo valido para el sistema operativo y debe incluir especificación de dirección
	
	\begin{tabular}{l|l}
		\textbf{Mode} & \textbf{Meaning}\\[.7ex]
		\hline
		''r" & Open a file for reading\\[.7ex]
		''w" & Create a file for writing\\[.7ex]
		''a" & Append to a file\\[.7ex]
		''rb" & Open a binary file for reading\\[.7ex]
		''wb" & Create a binary file for writing\\[.7ex]
		''ab" & Append to a binary file\\[.7ex]
		''r+" & Open a file for write/read\\[.7ex]
		''w+" & Create a file for read/write\\[.7ex]
		''a+" & Append or create a file fore read/write\\[.7ex]
		''r+b" & Open a binary file for read/write\\[.7ex]
		''w+b" & Create a binary file for read/write\\[.7ex]
		''a+b" & Append or create a binary file fore read/write\\[.7ex]
		''rt" & Open a text file for reading\\[.7ex]
		''wt" & Create a text file for writing\\[.7ex]
		''at" & Append to a text file\\[.7ex]
		''r+t" & Open a text file for read/write\\[.7ex]
		''w+t" & Create a text file for read/write\\[.7ex]
		''a+t" & Append or create a text file for read/write
	\end{tabular}
	
	Si quisieras abrir un archivo para escribir con nombre \textbf{test} entonces escribirias:\\
	
	FILE *fp;\\
	
	fp = fopen(''test", ''w");\\
	
	Sin embargo, usualmente lo varas escrito así:\\
	
	FILE *fp\\
	
	if ((fp = fopen(''test", ''w")) == NULL)
	
	$\lbrace$
	
	puts(''cannot open file$\backslash$n");
	
	exit(1);
	
	$\rbrace$\\
	
	La macro \textbf{NULL} está definida en STDIO.H. Este método detecta cualquier error abriendo un archivo, por ejemplo de protegido de escritura o disco lleno antes de intentar escribir en el. Un NULL es usado porque ningún archivo puntero tendría ese valor. También está la función \textbf{exit()}. Una llamada a \textbf{exit()} causa la inmediata terminación del programa, no importa de donde es llamada la función \textbf{exit()}, tiene un prototipo (encontrada en 	STDLIB.H):\\
	
	void exit(int \textit{val});\\
	
	Este valor es retornado al sistema operativo.
	
	Si usas \textbf{open()} para abrir un archivo para escribir, entonces cualquier archivo preexistente por ese nombre será borrado y comenzará un nuevo archivo. Si no existe un archivo por ese nombre, entonces uno será creado. Si quieres añadir a el final de un archivo, entonces debes usar el modo ''a". Abrir un archivo para leer operaciones, requiere que el archivo exista. Si no lo hace, un error será retornado. Finalmente, si un archivo es abierto para leer/escribir operaciones, este no será borrado si existe; sin embargo, si no existe se creará uno.
	
	\subsubsection{Escribir un caracter}
	
	la función \textbf{putc()} es usada para escribir caracteres a un stream previamente abierta para escribir por la función \textbf{fopen()} la función es declarada\\
	
	int putc(int \textit{ch}, FILE *\textit{fp});\\
	
	Donde \textit{fp} es el archivo puntero retornado por \textbf{fopen()} y \textit{ch} es el carácter de salida. El archivo puntero le dice a \textbf{putc()}que archivo de disco escribir en.Por razones históricas, \textit{ch} es formalmente llamado un \textbf{int} pero solo el byte de bajo orden es usado.
	
	Si una operación \textbf{putc()} es un éxito entonces va a retornar el carácter escrito. En un fallo, un \textbf{EOF} es retornado. \textbf{EOF} es un macro definido en STDIO.H que significa ''End-Of-File"
	
	\subsubsection{Leyendo un caracter}
	
	la función \textbf{getc()} es usado para leer caracteres de un stream abierto en modo de lectura por \textbf{fopen()}. la función es declarada como:\\
	
	int get(FILE *\textit{fp});\\
	
	Donde \textit{fp} es un archivo puntero de tipo \textbf{FILE} retornado por \textbf{fopen()}. Por razones históricas, \textbf{getc()} retorna un entero, pero el byte de alto orden es cero.
	
	la función \textbf{getc()} retornará una marca \textbf{EOF} cuando el final del archivo ha sido alcanzado o un error ha ocurrido. Por lo tanto para leer un archivo de texto hasta que la marca End-Of-File es leída, puedes  usar el siguiente codigo:\\
	
	ch = getc(fp);\\
	
	while(ch != EOF) $\lbrace$
	
	ch = getc(fp);
	
	$\rbrace$
	
	\subsubsection{Usando feof()}
	
	Un archivo de sistema ANSI puede también ser operado en dato binario. Donde una archivo es abierto por entrada binaria, es posible que un valor entero igual a la marca \textbf{EOF} puede ser leído. Esto causaría la previa rutina de indicar una condición EOF aun cuando el final físico de el archivo no ha sido alcanzado. Para resolver este problema, ANSI C incluye la función \textbf{feof()}, donde es usado para determinar el final de el archivo cuando se leen datos binarios. La función \textbf{feof()} tiene este prototipo:\\
	
	int feof(FILE *\textit{fp});\\
	
	Este prototipo está en STDIO.H. Retorna true si el final del archivo ha sido alcanzado; de otra manera, cero es retornado. Por lo tanto, la siguiente rutina lee un archivo binario hasta el final de que el final del archivo es encontrado.\\
	
	while(!feof(fp)) ch = getc(fp);\\
	
	por supuesto, este mismo método puede ser aplicado para archivos de texto así como archivos binarios.
	
	\subsubsection{Cerrando un archivo}
	
	La función \textbf{fclose()} es usado para cerrar un stream que ha sido abierto por una llamada a \textbf{fopen()}. Escribe cualquier dato aun en el búfer del disco (En informática, un búfer (del inglés, buffer) es un espacio de memoria, en el que se almacenan datos de manera temporal, normalmente para un único uso su principal uso es para evitar que el programa o recurso que los requiere, ya sea hardware o software, se quede sin datos durante una transferencia de datos I/O irregular o por la velocidad del proceso.) a el archivo y hace un cierre formal a nivel de sistema operativo en el archivo. fallar en el cierre de un stream invita a todo tipo de problemas incluyendo perdida de datos, destruir archivos y posibles intermitentes errores en tu programa. \textbf{fclose()} también cierra el archivo de bloque de control asociado con el stream y lo hace posible para rehúso. Posiblemente sea necesario cerrar on archivo antes de abrir otro.
	
	La funcion \textbf{fclose()} es declarada como:\\
	
	int fclose(FILE *\textit{fp});\\
	
	Donde \textit{fp} es el archivo puntero retornado por la llamada a \textbf{fopen()}. Un retorno de valor cero significa un exito cerrando operacion; cualquier otro valor indica error. Puedes usar la funcion estandar \textbf{ferror()} para determinar y reportar cualquier problema. Generalmente, el unico momento \textbf{fclose()} fallará es cuando un diskette (o su analogo moderno) ha sido prematuramente removido del drive o si no queda espacio en el diskette (o su analogo moderno).
	
	\subsubsection{ferror() y rewind()}
	
	la funcion \textbf{ferror()} es usada para determinar si una operación de archivo ha producido un error. Si un archivo es abierto en modo texto y un erroe en lectura o escritura ocurre, se retorna \textbf{EOF}. se usa \textbf{ferror()} para determinar que evento pasó. La funcion \textbf{ferror()} tiene el prototipo:\\
	
	int ferror(FILE *\textit{fp});\\
	
	Donde \textit{fp} es un archivo puntero valido. Retorna true si un error ha ocurrido durante la ultima operacion de archivo; retorn falso de otra manera. Porque cada operacion de archivo hace la condicion error, \textbf{ferror()} debería ser llamada inmediatamente despues de cada operacion de archivo; de otra manera, un error puede perderse. EL prototipo para \textbf{ferror()} está en STDIO.H.
	
	la funcion \textbf{rewind()} reseteará el localizador de posicion de archivo a el principio de el archivo especificado como su argumento. Su prototipo es:\\
	
	void rewind(FILE *\textit{fp});\\
	
	Donde \textit{fp} es un archivo punero valido. El prototipo para \textbf{rewind()} está en STDIO.H'
	
	\subsubsection{Usando fopen(), getc(), putc() y fclose()}
	
	las funciones \textbf{fopen()}, \textbf{getc()}, \textbf{putc()} y \textbf{fclose()} comprometen el minimo set de rutinas de archivo. Un simple ejemplo de usar \textbf{fopen()}, \textbf{putc()} y \textbf{fclose()} es el programa \textbf{ktod} abajo. Lee lacarteres desde el teclado y los escribe en un archivo de disco hasta que el signo de dolar es escito. EL archivo es especificado por el comando line. Por ejemplo, si llamas este programa \textbf{ktod}, entonces escribir \textbf{ktod test} te permitirá pasar lineas de texto hacia el archivo llamado test\\
	
	...$\backslash$learn c$\backslash$c ktod.c\\
	
	El programa complementar \textbf{dtos}, leerá cualquier archivo ASCII e imprime los contenidos en la pantalla.\\
	
	...$\backslash$learn c$\backslash$c dtos.c\\
	
	El siguiente programa copiará un archivo de cualquier tipo. Notese que los archivos son abiertos en modo binario y que \textbf{feof()} es usado para checar por el final del archivo.\\
	
	...$\backslash$learn c$\backslash$c feof.c\\
	
	\subsubsection{Using get() and putw()}
	
	En adición a \textbf{getc()} y \textbf{putc()}, están las funciones \textbf{putw()} y \textbf{getw()} estas funciones no están definidas por el ANSI C estardar. Estas son usadas para leer y escribir enteros de y desde un archivo de disco. Estas funciones trabajan exactamente como \textbf{putc()} y \textbf{getc()} excepto que en lugar de leer o escribir un solo carácter, estas leen o escriben un entero. Estas tienen el siguiente prototipo:\\
	
	int putw (int i, FILE *\textit{fp});\\
	
	int getw(FILE *\textit{fp});\\
	
	El siguiente fragmento de codigo escribirá un entero a el archivo de disco puntero por \textit{fp}:\\
	
	putw(10, fp);\\
	
	los prototipos por \textbf{getw()} y \textbf{putw} estan en STDIO.H\\
	
	\subsubsection{fgets() y fputs()}
	
	El sistema ANSI de C I/O incluye dos funciones que pueden leer y escribir cadenas desde streams: \textbf{fgets()} y \textbf{fputs()}. Sus prototipos se muestran aqui.\\
	
	char *fputs(char *str, FILE *\textit{fp});
	
	char *fgets(char *str, int \textit{length}, FILE *\textit{fp});\\
	
	La función \textbf{fputs()} trabaja como \textbf{puts()} excepto que escribe la cadena el el stream especificado. La funcion \textbf{fgets()} lee una dadena desde el stream especificado hasta que un caracter nueva linea es leido o hasta que carecteres \textit{length-1} han sido leidos. Si una nueva liea es leida, se volverá parte de la cadena. La cadena resultante será terminacion null.
	Los prototipos para \textbf{fgets()} y \textbf{fputs()} están en STDIO.H.
	
	\subsubsection{fread() y fwrite()}
	
	El sistema ANSI I/O provee dos funciones, llamadas \textbf{fread()} y \textbf{fwrite()}, que permiten la lectura y escritura de bloques de daos. Sus prototipos se miestran aquí:\\
	
	unsigned fread(void *\textit{buffer}, int \textit{num\_bytes}, int \textit{count}, FILE *\textit{fp});\\
	
	unsigned fwrite(void *\textit{fbuffer}, int \textit{num\_bytes}, int \textit{cout}, FILE *\textit{fp});\\
	
	En el caso de \textbf{fread()}, \textit{buffer} es un puntero a una región de memoria que va a recibir los datos desde el archivo. Para \textbf{fwrite()}, \textit{buffer} es un puntero a la información que será escrito en  el archivo. El numero de bytes a ser leídos o escritos es especificado por \textit{num\_bytes}. El argumento \textit{count} determina cuantos objetos pueden ser leidos o escritos. Finalmente, \textit{fp} es un archivo puntero a un stream abierto previamente. Ambas funciones tienen sus protipos en STDIO.H.
	
	La funcion \textbf{fread()} retorna el numero de objetos leidos, que pueden ser menos que \textit{count} si el final de el archivo es alcanzado o un error ocurrio. La funcion \textbf{fwrite()} retorna el numero de objetos escritos. Este valor será igual a \textit{count} a no ser que un error ocurra.
	 
	Mientras el archivo sea abierto como dato binario, \textbf{fread()} y \textbf{fwrite()} pueden leer y escribir cualquier tipo de informacion. Por ejemplo este programa escribe un \textbf{float} en el disco:\\
	 
	...$\backslash$learn c$\backslash$c fwrite\_fread.c\\
	 
	Como este programa ilustra, el buffer puede ser y seguido es, un a simple variable. Este programa tambien  introduce otro operador de C: \textbf{sizeof}. El operador de tiempo de compilación \textbf{sizeof} retorna el tamaño en bytes de la variable o el tipo de dato que precede.
	 
	una de las mas utiles aplicaciones de \textbf{fread()} y \textbf{fwrite()} involucra leer y escribir arreglos (o como verás despues, estructuras). Por ejemplo. este fragmento escribe los contenidos de un arreglo de punto flotante \textbf{sample} a el archivo \textbf{sample} usando un solo \textbf{fwrite()}:\\
	 
	...$\backslash$learn c$\backslash$c sample\_read.c
	 
	\subsubsection{fseek() y acceso aleatorio I/O}
	 
	Puedes hacer lectura y escritura aleatoria de operaciones usando el sistema ANSI C I/O con la ayuda de \textbf{fseek()}, que establece el localizador de posición del archivo. Su prototipo es:\\
	 
	int fseek(FILE *\textit{fp}, long \textit{numbytes}, int \textit{origin});\\
	 
	Aquí \textit{fp} es un archivo puntero retornado por una llamada a \textbf{fopen()}; \textit{numbytes} un entero long es el numero de bytes desde \textit{origin} para hacer la posicion actual; \textit{origin} es uyno de los siguientes macros definidos en STDIO.H:\\
	 
	\begin{tabular}{l|l|l}
		\textbf{Origin} & \textbf{Macro Name} & \textbf{Actual Value}\\
		\hline
		Begining of file & SEEK\_SET & 0\\[.7ex]
		Current position & SEEK\_CUR & 1\\[.7ex]
		End of file & SEEK\_END & 2
	\end{tabular}\\

	Por lo tanto para buscar \textit{numbytes} desde el inicio del archivo, \textit{origin} debería ser \textbf{SEEK\_SET}, para buscar desde la posicion actual debería ser \textbf{SEEK\_CUR}, para buscar desde el final debería ser \textbf{SEEK\_END}.\\
	
	El siguiente fragmento lee el byte 235 en un archivo que es llamado \textbf{test}.\\
	
	...
	
	FILE *fp;
	
	char ch;\\
	
	if((fp = fopen(''test", ''rb")) == NULL) $\lbrace$
	
	printf(Cannot open file$\backslash$n);
	
	exit(1);
	
	$\rbrace$\\
	
	fseek(fp, 234, 0);
	
	ch = getch(fp);
	
	...\\
	
	Un valor 0 de retorno  significa que \textbf{fseek()} tuvo éxito. Un valor diferente de 0 indica fallo.\\
	
	Un mas interesante ejemplo es el programa \textbf{DUMP}, que usa \textbf{fseek()} para dejarte examinar los contenidos en ASCII y hexadecimal de cualquier archivo elijas. Puedes mirar el archivo en sectores de 128bytes en cualquier dirección. La salida es similar en estilo a el formato usado por DEBUG cuando dado el comando ''D" (dump memory):\\
	
	...$\backslash$learn c$\backslash$c dump.c\\
	
	\subsubsection{Los streams estandar}
	
	Cuando un programa empieza su ejecución, 5 streams son abiertos automaticamente. Los primeros 3 son entrada estandar(stdin), salida estandar (stdout) y error estandar (stderr). Normalmente, estos refieren a la consola, pero pueden ser redireccionados por el sistema operativo para hacer otro dispositivo stream. Porque estos son archivos punteros pueden ser usados por el sistema ANSI I/O para realizar operaciones I/O en la consola. Por ejemplo, \textbf{putchar()} puede ser definido como:\\
	
	putchar(char c)
	
	$\lbrace$
	
	putc(c, stdout);
	
	$\rbrace$\\
	
	Puedes usar \textbf{stdin}, \textbf{stdout} y \textbf{stderr} como archivos punteros en cualquier funcion que usa una variable de tipo \textbf{FILE *}.
	
	Las funciones I/O de consola \textbf{getchar()}, \textbf{putchar()}, \textbf{printf()} y \textbf{scanf()} de hecho realizan sus operaciones I/O usando \textbf{stdin} y \textbf{stdout}. Desde que DOS permite redireccionar I/O usando los operadores de linea de comando $>$ y $<$, estas funciones pueden tambien ser leidas y escritas en archivos de disco. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c iotest.c\\
	
	Como puedes ver, nada se despliega en la pantalla. Sin embargo si enlistas los contenidos \textbf{OUT} verás que el mensaje ha sido escrito en el.
	
	Debes mantener en mente que \textbf{stdin}, \textbf{stdout} y \textbf{stderr} no son variables sino constantes. Ademas, tambien así como son creados al inicio de tu programa automaticamente, tambien son cerrados automaticamente al terminar el mismo; no debes intentar cerrarlos tu mismo.
	
	\subsubsection{fprintf() y fscanf()}
	
	En adicion a las funciones basicas I/O discutidas, el sistema ANSI C I/O incluye \textbf{fprintf()} y \textbf{fscanf()}. Estas funciones funcionan exactamente como \textbf{printf()} y \textbf{scanf()}, excepto que estas operan con archivos de disco. Los prototipos de \textbf{fprintf()} y \textbf{fscanf()} son:\\
	
	int fprintf(FILE *fp, char *control\_string,...);
	
	int fscanf(FILE *fp, char *control\_string,...);\\
	
	Donde \textit{*fp} es un archivo punter retornado por una llamada de \textbf{fopen()}. Excepto por dirigir su salida a el archivo definido por \textit{*fp}, estas operan exactamente como \textbf{fprintf()} y \textbf{fscanf()}, respectivamente.
	
	Para ilustrar lo utiles que estas funciones pueden ser, el siguiente programa mantiene un simple directorio telefonico en un archivo de disco. Podrias ingresar numeros o puedes buscar un numero dado un nombre:\\
	
	...$\backslash$learn c$\backslash$c fprintf\_fscanf.c\\
	
	Aunque \textbf{fprintf()} y \textbf{fscanf()} seguido son la forma mas sencilla de escribir y leer datos a archivos de disco, estos no son siempre los mas eficientes. Por que el sistema formateado ASCII está siendo escrito directamente como aparecería en pantalla, en lugar de en binario. Entonces si la velocidad o el tamaño del archivo es una preocupacion, deberias probablemante usar \textbf{fread()} y \textbf{fwrite()}.
	
	\subsubsection{Borrando archivos}
	
	la función \textbf{remove()} borra el archivo especificado. su prototipo es\\
	
	int remove(char *\textit{filename});\\
	
	retorna cero si es un exito, no-cero si falla
	
	\subsection{Las Rutinas de archivo tipo UNIX}
	
	Ya que C fue diseñado inicialmente bajo el sistema operativo UNIX, un segundo archivo de disco de sistema I/O fue creado. ysa funciones que son separadas de las funciones del sistema de archivos ANSI
	
	\section{Tipos de dato avanzados}
	
	\subsection{Modificadores de acceso}
	
	C tiene 2 tipos de modificadores de acceso que son usadas para controlar las formas en que las variables pueden ser accesadas o modificadas. Estos modificadores son llamados \textbf{const} \textbf{volatile}. Tambien son comunmente referidas como \textit{cualificadores de tipo}
	
	\subsubsection{const}
	
	Variables declarados con el modificador \textbf{const} no podrian ser cambiadas durande la ejecucion de tu programa. Podrias darles un valor inicial, por ejemplo:\\
	
	const float version = 3.20;\\
	
	Crea una variable \textbf{float} llamada \textbf{version} que no podria ser modificada por tu programa. Puede sin embargo ser usada en otro tipo de expresiones.
	
	Las variables de tipo \textbf{const} tienen un uso  muy importante, estas pueden proteger los argumentos a una funcion de ser modificado por esa funcion. Esto es, cuando un puntero es pasado a una funcion, esto es posible para esa funcion modificar la variable apuntada por el puntero. Sin embargo si el puntero es especificado como \textbf{const} en la declaracon de parametros su valor no podra ser modificado, por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c const.c\\
	
	Si por alguna razon intentas modificar el argumento, no compilara correctamente e imprimira el siguiente error\\
	
	Cannot modify a const object in the function \textit{name}\\
	
	El segundo uso para \textbf{const} es para verificar que de hecho tu programa no modifica una variable. Recuerda que una variable puede ser modificada por algo fuera de tu programa, sin embargo de esta forma aseguras que ningun cambio en la variable es por tu programa, sino por eventos externos.
	
	\subsubsection{volatile}
	
	El modificador \textbf{volatile} es usado para decirle al compilador que el valor de una variable puede cambiar en formas que no estan especificadas por el programa. Por ejemplo, la direccion de una variable global puede ser pasada a la rutina de el sistema operativo y usada para mantener el tiempo real del sistema. En esta situacion los contenidos de la variable seran alterados sin algun asignamiento explicito en el programa. Ahora considera el siguiente fragmento de codigo:\\
	
	int clock, timer;\\
	.\\
	.\\
	.\\
	timer = clock;\\
	/*do Something*/\\
	printf(''Elapsed time is \%d$\backslash$n", clock-timer);\\
	
	Porque \textbf{clock} no es alterada por el programa y no esta declarada como \textbf{volatile} Puede ser optimizado de tal forma en que el valor de \textbf{clock} no es reexaminado por \textbf{printf()}. Sin embargo si declaras \textbf{clock} como:\\
	
	volatile int clock;\\
	
	Entonces no ocurrira esa optimizacion y el valor de \textbf{clock} sera reexaminado cada vez que sea referenciado
	
	Aunque pueda parecer extraño, es posible utilizar \textbf{const} y \textbf{volatile} juntas. Por ejemplo, si 0x30 es asumido ser el valor de un puerto que es cambiado solo por condiciones externas, entonces la siguiente declaracion es precisamente lo que quieres para prevenir cualquier posible efecto secundario accidental:\\
	
	const volatiole unsigned har *port=0x30;\\
	
	\subsection{Especificadores de guardado de clase }
	
	Hay 4 especificadores de guardado de clase soportados por C:
	
	\begin{itemize}
		\item auto
		\item extern
		\item static
		\item register
	\end{itemize}

	Estos son usados para decirle al compilador como la variable que sigue deberia ser guardada. El especificador de guardado precede al resto de las declaraciones de variable. Su forma general es:\\
	
	\textit{storage-class-soecufuer type-specifier variable-list;}\\
	
	\subsubsection{auto}
	
	El especificador \textbf{auto} es usado para declarar variables locales. Sin embargo este es raramente usado porque las variables locales son \textbf{auto} por default. Es extremadamente raro ver esta palabra clave en un programa
	
	\subsubsection{extern}
	
	Todos los programas con los que has estado trabajando hasta el momento han sido pequeños. sin embargo en verdadera tareas de programación, los programas tienen a ser mucho mas largos. hasta el punto en que sin importar lo veloz que sea tu compilador, el tiempo de compilación crece tanto que se vuelve molesto. Cuando esto sucede deber romper tu programa en 2 o mas archivos separados. De esta manera pequeños cambios en un archivo no requiere que todo el programa sea recompilado, lo que significa salvar mucho tiempo en largos proyectos.
	
	C contiene la palabra clave \textit{extern}, que ayuda a soportar el acercamiento de múltiples archivos.
	
	Ya que C permite separadamente compilar módulos de un programa largo para ser unido junto para acelerar la compilación y la ayuda en el manejo de largos proyectos, debería haber alguna manera de decirle a todos los archivos sobre las variables requeridas para el programa. Tu programa puede solo tener una copa de cada variable global. Si tratas de declarar dos variables globales con el mismo nombre en el mismo archivo, el compilador simplemente elije una y la usa (En C++ sin embargo es un error el declarar 2 variables con el mismo nombre). Si tu tratas de declaras las variables globles necesitadas por tu programa en cada archivo de un programa multi-archivo, estarás en problemas. Aunque el compilador no manda un mensaje de error en tiempo de compilación, estas tratando de crear 2 o mas copias de cada variable. Esto será encontrado por el enlazador cuando intente unir tus módulos juntos. El enlazador mandará un mensaje de error porque no sabrá que variable usar. La solución es declarar todas tus globales en un archivo y usar \textbf{extern} en los demás archivos.
	
	\subsubsection{Variables static}
	
	Variables de tipo \textbf{static} son variables permanentes en ya sea su propia funcion o el archivo, estas difieren de las varibles globlesporque no son conocidas fuera de su funcion o archivo, pero si mantienen sus valores entre llamadas. esta caracteristica puede hacerlas bastante utiles cuando estribes funciones generanlizadas y librerias de funciones, que pueden ser utilizadas por otros programadores.
	
	\subsubsection{Variables locales static}
	
	Cuando el modificador \textbf{static} es usado a una variable local, hace que el compilador cree un almacenamiento permanente en basicamente la misma forma en que hace con las variables globales. La principal diferencia entre una variable \textbf{static} y una variable global es que la variable \textbf{static} se mantiene solo en el bloque en que es declarada. En otras palabras, una variable local  \textbf{static} es una variable local que mantiene su valor entre llamadas. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c static.c\\
	
	\subsubsection{Variables globales static}
	
	cuando el especificador \textbf{static} es aplicado a una variable global, le instruye al compilador crear una variable que es conocida solo por el archivo en el que se declara. Esto significa que aunque la variable sea local, otras rutinas en otros archivos, no podrian tener conocimiento de el o alterar su valor directamente.
	
	Las variables \textbf{static} te permiten esconder porciones de tu codigo de otras porciones. Esta puede ser una tremenda ventaja cuando estas escribiendo para manejar un muy largo y complejo programa. El especificador de almacenamiento \textbf{static} te permite crear funciones muy generales que puedes guardar en librerias para su posterior uso.
	
	\subsubsection{Variables register}
	
	Otro importante tipo de modificador encontrado en C es llamado \textbf{register} y es tradicionalmente aplicado a variables de tipo \textbf{int} y \textbf{char}. El modificador \textbf{register} le pide al compilador acceder a esa variable lo más rápido posible, esto para los tipos de dato \textbf{int} y \textbf{char} significa que son guardadas en el cache del cpu\\
	
	El especificador register solo es aplicable para variables locales y sus parametros, variables globales \textbf{register} no son validas es importante saber que \textbf{register} no es un comando, es una peticion, pues exsiste un limitado numero de locaciones de acceso rapido. cuando estos espacios se terminen, las demas variables declaradas con \textbf{register} se trataran como cualquier otra variable. Ejemplo:\\
	
	...$\backslash$learn c$\backslash$c register.c\\
	
	\subsection{Punteros de funciones}
	
	Una particularmente confusa y aun así poderosa cualidad de C es el \textbf{archivo puntero}. Una funcion puntero es, de cierta forma, un nuevo tipo de dato. Aun cuando una funcion, no es una variable, aun tiene una locacion fisica en memoria que puede ser asignada a un puntero. La direccion asignada al puntero es el punto de entrada de la funcion. Este puntero puede despues ser usado en lugar del nombre de la funcion. Tambien permite a la funcion ser pasada como argumento de la funcion.
	
	Veamos como se llaman y se compilan las funciones en C. Primero cada funcion es compilada, codigo fuente es transformado a un objeto y un punto de entrada es establecido. Cuando una llamada se hace a la funcion mientras tu program corre, una ''llamada" en lenguaje maquina es hecha a este punto de entrada. Por lo tanto un puntero a una funcion de hecho contiene la direccion de memoria a el punto de entrada de la funcion.
	
	La direccion de una funcion es obtenida usando el nombre de la funcion sin algun parentesis o argumentos. Por ejemplo:\\
	
	...$\backslash$learn c$\backslash$c function\_pointer.c\\
	
	...$\backslash$learn c$\backslash$c function\_pointer2.c\\
	
	\subsection{Asignación dinámica de memoria}
	
	Antes de abandonar el tema de tipos de dato avanzados, es necesario discutir sobre la asignación dinámica de memoria de C, que nos permite la creación de variables durante la ejecución del programa.
	
	Existen 2 maneras principales en que un programa de C puede guardar información en la memoria principal de la computadora. La primera usa variables globales y locales que estan definidas por el lenguaje C, en ambos casos se requiere que el programador sepa preferentemente la cantidad de espacio de almacenamiento necesario para cualquier situación. La segunda manera es atravez de el uso del sistema de asigamiento dinamico de memoria de C.\\
	
	\subsection{Asignación y liberación de memoria}
	
	El centro del sistema de asignación dinámica de memoria de C son las funciones \textbf{malloc()} y \textbf{free()}. Estas trabajan juntas usando la region de memoria libre para establecer y mantener una lista de almacenaje disponible. La funcion \textbf{malloc()} asigna la memoria y \textbf{free()} la libera. La funcion \textbf{malloc()} tiene su prototipo:\\
	
	void *malloc(unsigned \textit{number\_of\_bytes});\\
	
	Retorna un puntero de tipo void, lo que significa que puedes asignarlo a cualquier tipo de puntero. Puedes usar \textbf{sizeof()} para determinar exacto numero de bytes necesarios para cada tipo de dato. De esta manera puedes hacer tus programas portables a una variedad de sistemas.
	
	La función \textbf{free()} es el opuesto de \textbf{malloc()}. una vez la memoria ha sifo liberada puede ser usada por una subsecuente llamada a \textbf{malloc()}. La función \textbf{free()} tiene el siguiente prototipo:\\
	
	void free(void *p);
	
	ejemplo:\\
	
	...$\backslash$learn c$\backslash$c free.c\\
	
	La locacion dinamica de memoria es muy buena cuando no sabes por adelantado, con cuantos objetos de dato estas tratando. Aunque ejemplos importantes de la locacion dinamica suelen ser largos y complejos, el siguiente ejemplo te dará el sabor de su uso:\\
	
	...$\backslash$learn c$\backslash$c free2.c\\
	
	\section{Tipos definidos por el usuario}
	
		C te permite crear 5 diferentes tipos de datos customizados. El primero es el \textit{structure}, que es un agrupador de variables bajo un mismo nombre. El segundo tipo es el \textit{bit-field}, que es un tipo de estructura que permite acceso sencillo a los bits en una palabra. El tercero es el \textit{union}, que permite a la misma pieza de memoria ser definida como 2 o mas tipos de variables. El cuarto tipo es el \textit{enumeration}, que es una lista de simbolos. El quinto tipo de archivo es creado a travez del uso de \textbf{typedef} y crea un nuevo nombre para un tipo existente.
		
		\subsection{Structures}
		
			Una estructura es una colección de variables que se referencian bajo un nombre, brindando una forma conveniente de mantener la información relacionada junta. Una \textit{Estructura de declaración}, forma una plantilla que puede ser usada para crear estructuras de variables. Las variables que comprenden la estructura son llamados elementos de estructura o miembros de estructura. La palabra clave \textbf{struct} le dice al compilador que una estructura plantilla ha sido creada, ej:\\
			
			struct addr\{
			
			char name[30];
			
			char street[40];
			
			char city[20];

			char state[30];
			
			unsigned long int zip;
			
			\};\\
			
			La declaracion es terminada por un punto y coma. Esto es porque la declaración de una estructura es un estatuto, donde \textit{addr} es el especificador de tipo e identifica esa particular estructura de datos.
			
			Hasta este punto no se han declarado variables. Solo se ha definido la forma de la estructura de datos, para declarar variables se haría por ejemplo:\\
			
			struct addr\{
			
			char name[30];
			
			char street[40];
			
			char city[20];
			
			char state[30];
			
			unsigned long int zip;
			
			\}addr\_info, binfo, cinfo;\\
			
			Si solo necesitas una variable estructura, entonces el identificador de tipo no es necesario, quedando en este caso:\\
			
			struct\{
			
			char name[30];
			
			char street[40];
			
			char city[20];
			
			char state[30];
			
			unsigned long int zip;
			
			\}addr\_info;\\
			
			\subsubsection{Referenciando miembros de una estructura}
			
				Los miembros individuales de una estructura son referenciadas a travez de el uso de el operador de seleccion de miembro: el punto (tambien llamado \textit{Operador punto}). Por ejemplo:\\
			
				addr\_info.zip = 12345;\\
			
				Todos los elementos de estructuras se accesan de la misma manera, Teniendo la forma general de:\\
			
				\textit{structure\_varname.element\_name}\\
			
			\subsection{Arreglos de estructuras}
			
			El uso mas comun de estructuras es en arreglos de estructuras. Para declarar un arreglo de estructuras, primero debes definir una estructura y despues declarar una variable arreglo de ese tipo
			
			...$\backslash$learn c$\backslash$c mailing\_list.c\\
			
			\subsection{Assignando estructuras}
			
			Si 2 estructuras son de un mismo tipo, puedes entonces asignar la una a la otra. En este caso, todos los elementos de la estructura en el lado izquierdo de el asignamiento, recibirá los valores de sus correspondientes elementos de la estructura ej la derecha. por ejemplo:\\
			
			...$\backslash$learn c$\backslash$c assigning\_structures.c\\
			
			Recuerda, no puedes asignar una estructura a otra si son de diferente tipo, incluso si comparten algunos elementos
			
			
			\subsection{Pasar elementos de estructuras a funciones}
			
			Hasta ahora, todas las estructuras y arreglos de estructuras se ha asumido que son globales o definidas en la funcion que las usa. En esta seccion se tomará en consideracion especial aa pasar estructuras y sus elemetos a funciones.
			
				\subsubsection{Pasando elementos de estructura a funciones}
				
				Pasar un elemento de una estructura, es solamente pasar una variable, a no ser que sea un elemento complejo, como un arreglo de caracteres; sin embargo, si deseas pasar la direccion de un elemento de la estructura, tienes ue poner el operador \& antes del nombre de la variable de estructura, no del elemento
				
				\subsubsection{Pasar estructuras enteras a funciones}
				
				Cuando una estructura es pasada como argumento de una funcion, toda la estructura es pasada usando la llamada estandar por valor. Esto por su puesto significa que cualquier cambio hecho a los conenidos de la estructura dentro de la funcion a la cual es pasada no afecta la estructura usada como un argumento por ejemplo:\\
				
				...$\backslash$learn c$\backslash$c struct\_param.c\\
				
			\subsection{Punteros a estructuras}
			
			C permite punteros a estructuras de la misma forma que permite punteros a cualquier otro tipo de variable. Sin embargo, existen cientos aspectos especiales de los que debes estar al tanto.
			
				\subsubsection{Declarando un puntero de estructura}
				
				Los punteros de estructura, son declarados colocando \textbf{*} frente al nombre de la variable de estructura por ejemplo:\\
				
				struct addr *addr\_pointer;\\
				
				\subsubsection{Usando punteros de estructura}
				
				Existen varios usos para los punteros de estructura, uno es el de archivar una llamada por referencia a una funcion. Otro es crear una lista linkeada y otras estructuras dinamicas de datos (\textit{Turbo C/C++: The Complete Reference})
				
				Existe un gran contratiempo al pasar estructuras enteras a funciones y es el esfuerzo para mover toda la estructura de elementos. En simples estructuras, con algunos elementos, este esfuerzo no es demasiado importante, pero si es una estructura de varios elementos o si estos son arreglos, entonces este esfuerzo puede degradar el tiempo de ejecución a niveles inaceptables. La solución a este problema está en los punteros a estructuras. Ejemplo:\\
				
				struct\{
				
				float balance;
				
				char name;
				
				\}person;\\
				
				struct bal *p = \&person;\\
				
				Para accesar a \textbf{balance} podrías escribir:\\
				
				(*p).balance\\
				
				Es extraño ver, si alguna vez lo haces, el encontrar que se utilice explicitamente el operador * para accesar a una estructura atravez de un puntero, es algo tan comun que de hecho existe un operador especial para esta tarea, es el \textit{->}, al cual la mayoria de los programadores de C llaman el operador \textit{flecha}. Por ejemplo, para escribir lo anterior se haría:\\
				
				p-\textgreater balance\\
				
				Ejemplo:\\
				
					...$\backslash$learn c$\backslash$c struct\_pointer.c\\
					
				Recuerda, debes usar el operador punto cuando trabajes con la estructura en si, cuando tengas un puntero a la estructura, utiliza el operador flecha, tambien recuerda que debes pasar la direccion de la estructura con el \textbf{\&}.\\
				
				Vamos a explorar algunas de las funciones de tiempo y fecha de C. Las funcionese que tratan con el sistema de tiempo y fecha, requieren el archivo de cabecera TIME.H para sus prototipos. Tambien se incluye en este archivo de cabecera 2 tipos definidos. El \textbf{time\_t} es capaz de representar el sistema tiempo y fecha como un entero largo. este es referido como el \textit{tiempo calendario}. La estructura de tipo \textbf{tm} mantiene la fecha y el tiempo partido en sus elementos. La estructura \textbf{tm} es definida de esta manera:\\
				
				struct tm\{
				
				int tm\_sec; // seconds, 0-59
				
				int tm\_min; // munutes, 0-59
				
				int tm\_hour; // hours, 0-23
				
				int tm\_mday; // day of the month 1-31
				
				int tm\_mon; // months since Jan, 0-11
				
				int tm\_year; // years form 1900
				
				int tm\_wday; // days since Sunday 0-6
				
				int tm\_yday; // days since Jan 1, 0-365
				
				int tm\_isdst; // daylight savings time indicator
				
				\}
					
					
				El valor de \textbf{tm\_isdst}  será positivo si el tiempo de verano esta en efecto, 0 si está inactivo o un valor negativo si no se tiene informacion sobre ello. Esta forma de fecha y tiempo es llamada \textit{broken-down time}.
				
				la fundacion por el tiempo y la fecha de C es \textbf{time()} que tiene el prototipo:\\
				
				time\_t time(time\_t *time);\\
				
				La funcion \textbf{tiempo()} retorna el numero de segundos que han pasado desde enero 1 1970. Puede ser llamado con un puntero nulo o con un puntero a una variable de tiempo \textbf{time\_t}
				
				Para convertir de tiempo de calendario a \textit{broken-down time}, usa \textbf{localtime()}, que tiene este prototipo:\\
				
				struct tm *localtime(time\_t *time);\\
				
				La estructura usada por \textbf{localtime()} es estaticamente alocada y es sobreescrita cada vez que la funcion es llamada. Si deseas guardar los contenidos de la estructura, es necesario copiarlo en otro lado.
				
				Aunque tu programa puede utilizar la forma \textit{broken-down} de el tiempo y fecha, la forma mas sencilla de generar una cadena de tiempo y fecha es por el uso de \textbf{asctime()} cuyo protortipo es:\\
				
				char *asctime(struct tm *ptr);\\
				
				La funcion \textbf{asctime()} retorna un puntero a una cadena de la forma:\\
				
				day month date hours:minutes:seconds year$\backslash$n$\backslash$0\\
				
				El puntero de estructura pasada a \textbf{asctime()} es la obtenida por \textbf{localtime()}
				
				Como \textbf{localtime()} es estaticamente alocada y es sobreescrita cada vez que la funcion es llamada. Si deseas guardar los contenidos de la estructura, es necesario copiarlo en otro lado. Ejemplo:\\
				
				...$\backslash$learn c$\backslash$c time.c\\
				
			\subsection{Arreglos y estructuras en estructuras}
				
			Miembros de estructuras pueden ser de cualquier tipo de dato de C, incluyendo arreglos y estructuras. Por ejemplo:\\
				
			struct x \{
				
			int a [10][10];
				
			float b;
				
			\} y;\\
				
			para referenciar al entero 3,7 en \textbf{a} de la estructura \textbf{y} escribirias:\\
				
			y.a[3][7];\\
				
			Cuando una estructura es elemento de otra estructura, se llama estructura \textit{anidada}. Por ejemplo:\\
				
			struct emp \{
				
			struct addr address;
				
			float wage;
			
			\} worker;\\
				
				
			Para referenciar a un elemento de \textit{address} en \textbf{emp} escribirias:\\
				
			worker.address.\textit{variable};\\
				
			\subsection{Bit-fields}
			
			A diferencia muchos otros lenguajes, C tiene un metodo intrinseco para accesar a uno o mas bits en un byte o palabra. Esto pude ser util para un numero de razones:
			
			\begin{itemize}
				\item Si el almacenamiento es limitado, puedes guardar varias variables \textit{booleanas} en un byte
				\item Cierta interfaz de un dispositivo transmite informacion codificada en bits dentro de un byte
				\item Cierta encriptacion de rutinas necesita accesar los bits en un byte
			\end{itemize}
		
			Un metodo que C usa para accesar bits es basado en la estructura llamada \textit{bit-field}. un \textit{bit-field} es solo un tipo de miembro de estructura que define en bits que tal largo cada elemento es. La forma general de la declaracion de un campo de bits es:\\
			
			struct \textit{struct-type-name}\{
			
			\textit{type name1 : length;}

			\textit{type name2 : length;}
			
			...
			
			\textit{type nameN : length;}
						
			\}\\
			
			Un campo de bits debe ser declarado como \textbf{int}, \textbf{unsigned} or \textbf{signed}. Campos de bits de longitud 1 deben ser declarados como \textbf{unsigned} porque un solo bit no puede tener un signo.\\
			
			No tienes que nombrar cada campo de bits. Esto hace sencillo alcanzar el bit que quieres, pasando los no usados, por ejemplo:\\
			
			struct equip\{
			
			unsigned floppy\_boot: 1;
			
			unsigned has8087: 1;
			
			unsigned mother\_ram: 2;
			
			unsigned video\_mode: 2;
			
			unsigned floppies: 2;
			
			unsigned dma: 1;
			
			unsigned ports: 3;
			
			unsigned game\_adapter: 1;
			
			unsigned : 1;
			
			unsigned num\_printers: 2;
			
			\} eq;\\
			
			Las variables bit-field tienen ciertas restricciones:
			
			\begin{itemize}
				\item No puedes tomar la direccion de una variable bit-field.
				\item Las variables bit-field no pueden ser arraigadas.
				\item No puedes sobrelapar fronteras de enteros.
				\item Si el campo correrá de izquierda a derecha o de derecha a izquierda variará en diferentes CPU; Esto implica que cualquier codigo que use campos de bits puede tener algounas dependencias a maquina.
			\end{itemize}
		
			Es valido mezclar estructuras normales con miembros de campos de bits. Por ejemplo:\\
			
			struct emp\{
			
			struct addr address;
			
			float pay;
			
			unsigned lay\_off: 1;
			
			unsigned hourly: 1;
			
			unsigned deductions: 3;
			
			\};\\
			
			Esta estructura define el record de un empleado que usa solo un byte para mantener 3 piezas de informacion: el estado del empleado, si es salariado y el numero de deducciones. Si el uso de campos de bits, esta información habria tomado 3 bytes.
			
			\subsection{Uniones}
			
			En C, una \textbf{union} es una locacion de memoria que es usada por diferentes variables de diferentes tipos. La declaracion de una \textbf{union} es similar a la de una estructura, por ejemplo:\\
			
			union u\_type \{
			
			int i;
			
			char ch;
			
			\};\\
			
			Como en las estructuras, esta declaracion no declara alguna variable. Puedes declarar una variable ya sea colocando su nombre al final de la declaracion o usando una declaracion separada. Para declarar una \textbf{union} variable \textbf{cnvt} de tipo \textbf{u\_type} usando la declaracion ya dada, se escribiria:\\
			
			union u\_type cnvt;\\
			
			En \textbf{cnvt}, ambos enteros \textbf{i} y el caracter \textbf{ch} comparten la misma locacion de memoria. (por lo tanto, \textbf{i} ocupa 2 bytes y \textbf{ch} ocupa solo 1)
			
			Cuando una variable \textbf{union} es declarada, el compilador automaticamente creará una variable lo suficientemente larga para mantener el tipo de variable mas largo en la \textbf{union}
			
			Para accesar a un elemento de la \textbf{union} usas la misma sintaxis que se usa para estucturas:\\ 
			
			\begin{itemize}
				\item Operador punto
				\item Operador flecha
			\end{itemize}
		
			Las uniones son usadas frecuentemente cuando conversiones de tipo son necesarios porque te dejan tomar una region de memoria en mas de una manera. por ejemplo:\\
			
			void putw(union pw word, FILE *fp)\{
			
			putc(word$->$ch[0], fp);
			
			putc(word$->$ch[1], fp);
			
			\}\\
			
			Aunque llamado con un entero, \textbf{putw()} puede aun usar la funcion estandar \textbf{putc()} para escribir un entero a un archivo de disco
			
			el siguiente programa combina uniones con campos de bits para desplegar el codigo ASCII, en binario, generado cuando presionas una tecla. La \textbf{union} permite a \textbf{getche()} asignar el valor de la tecla a un caracter variable mientras el campo de bits es usado para desplegar los bits individuales (Este programa es solo para ilustrar como uniones pueden ser usadas para  buscar en la misma pieza de memoria de 2 formas diferentes. Hay muchas maneras mas eficientes de escribir la funcion \textbf{deconde()} que alcanzan el mismo resultado).\\
			
			...$\backslash$learn c$\backslash$c union.c
			
			\subsection{Enumeraciones}
			
			Una enumeracion es un conjunto de nombres de constantes enteras y especifica todos los valores legales que una variable de tipo puede tener. Son definidas mucho como estructuras con la palabra clave \textbf{enum} usada como señal de inicio de un tipo de enumeracion, la forma general es mostrada aquí:\\
			
			enum \textit{enum-type-name \{ enumeration list \} variable-list};\\
			
			la lista de enumeracion es una lista de nombres separada por comas que representa los valores que una variable de el tipo enumeracion puede tener. Ambos, la lista de tipo enumeracion y la lista de variables es opcional. Como en estructuras, el nombre de enumeracion de tipo es usado para declarar variables de su tipo. Por ejemplo:\\
			
			enum coin\{ penny, nickel, dime, quarter, half\_dollar, dollar\};\\
			
			enum coin money;\\
			
			Dadas estas declaraciones, los siguientes tipo de sentencias son perfectamente validas:\\
			
			money = dime;\\
			
			if(money == quarter) printf(''is a quarter$\backslash$n");
			
			La clave para entender las enumeraciones es que cada uno de lso simbolos, se establece para un valor entero, así pueden ser usadps en cualquier expresion entera. A no ser que sea iniciado de otra forma, el primer simbolo inicia en cero, el valor del segundo es 1 y así continúa.\\
			
			Una común pero errónea asunción es que los simbolos pueden ser input o output directamente. Por ejemplo, este codigo no preformará como se desea:\\
			
			money = dollar;\\
			
			printf(''\%s", money);
			
			\subsection{Usando sizeof para asegurar portabilidad}
			
			Has visto que  estructuras, uniones y enumeraciones pueden ser usadoas para crear variables de tamaños variables, y que el propio temaño de estas variables puede cambiar de maquina a maquina. El operador unario \textbf{sizeof} es usado para computar el tamaño de cualquier variable o tipo y puede ayudar a eliminar dependencia de maquina en el codigo de tu programa.
			
			El operador \textbf{sizeof} toma las dos formas mostradas aquí:\\
			
			sizeof \textit{var-name}\\

			sizeof (\textit{type-name})
			
			\subsection{typedef}
			
			C te permite explicitamente fedinir unevos tipo de datp usando la palabra clave \textbf{typedef}. No estás de hecho creando nuevos tipos de dato, sino definiendo un nuevo nombre para un tipo de dato ya existente. Este proceso puede ayudar a hacer programas dependentes de maquina mas portables; solo hace falta cambiar la sentencia de \textbf{typedef}. Tambien puede ayudar a documentar tu codigo permitiendo nombres descriptivos para los tipos de dato estandar, la forma general de \textbf{typedef} es:\\
			
			typedef \textit{type name};
			
			Puedes usar typedef para definir tipos complejos de variables, por ejemplo:\\
			
			typedef struct client\_type\{
			
			float due;
			
			int over\_due;
			
			char name[40];
			
			\} client;\\
			
			client clist[NUM\_CLIENTS];\\
			
			En este caso, \textbf{client} no es una variable de tipo client\_type, sino otro nombre para \textbf{struct client\_type}.
			
			Usando typedef puede ayudar a hacer tu codigo mas facil de leer y mas facil de portar a otra computadora. Pero recuerda que no estas nuevos tipos de dato.
			
		\section{Operadores avanzados}
		
		A diferencia de otros lenguajes, C contiene muchos tipos de operadores especiales que en gran medida aumenten su poder y flexibilidad -especialmente para programacion a nivel de sistema.
		
			\subsection{Operadores bitwise}
			
			A diferencia de muchos otros lenguajes, C soporta un completo arsenal de operadores bitwise. Como C fue diseñado para tomar el lugar del lenguaje ensamblador para la mayoria de as tareas de programacion, era importante que tuviera la hablidad de soportar todas (o al menos muchas) operaciones que pueden hacerse en ensamblador. \textit{operadores bitwise} se refieren a testing, setting or shifting del propio bit en un byte o palabra, que corresponde en C a los tipos de dato char, int o long. Los operadores bitwise no deberias ser usados con los tipos de dato float, double, long double, void o otros tipos mas complejos:\\
			
			\begin{tabular}{l|l}
				\textbf{Operator} & \textbf{Action}\\
				\hline
				\& & AND\\
				\textbrokenbar & OR\\
				$\wedge$ & XOR\\
				$\sim$ & NOT\\
				$>>$ & Shift right\\
				$<<$ & Shift left
			\end{tabular}\\
		
			Las operaciones bitwise son muy seguido encontradoes en drivers, programas modernos, rutinas de archivos de disco, rutinas de impresion y porque similares, pues estas pueden ser usadas para enmascarar ciertos bits, como una paridad. (La paridad de bits es usada para confirmar que el resto de los bits en el byte estan sin cambios. Esto es usualmente los bit de alto orden en cada byte)
			
			En terminos de sus mas comunes usos, puedes pensar en el bitwise AND como una forma de apagar bits. Esto es que cualquier bit que es 0 en cualquier operando, causara el correspondiente bit en la variable ser establecido como 0.
			
			\clearpage
			
			\begin{figure}[!h]
					\begin{center}
						\large{\textbf{''A" \& 127}} \\
						\begin{tabular}{|l l|}
							\hline
							\hspace{7pt}parity bit & \\
							\hspace{7pt}$\downarrow$ & \\
							\hspace{7pt}11000001 & 
							\hspace{7pt}\textbf{ch} containing an ''A" with parity set\\
							\hspace{7pt}01111111 & 127 in binary\\
							\&\line(1,0){43} & do bitwise AND\\
							\hspace{8pt}01000001 & ''A" without parity\\
							\hline
						\end{tabular}
					\end{center}
			\end{figure}
		
			En general, bitwise ANDs, ORs y XORs aplican sus operaciones directamente en cada bit en la variable y no son usualmente usadas en sentencias condicionales de la manera en que los operadores relacionales logicos son usados. Por ejemplo, si $x=7 \rightarrow x\&\&8=true$, but $x\&8=false$.\\
			
			Los operadores relacionales y logicos, siempre dan como resultado 0 o 1, mientras que sus similares bitwise, pueden producir cualquier valor arbitrario en acordanza con la operacion especifica.\\
			
			El operador AND  es tambien util cuando quieres revisar si un bit está encendido o apagado. Por ejemplo:\\
			
			if(status \& 8) printf(''bit 4 is on");\\
			
			Un interesante uso de este proceso es la funcion \textbf{disp\_binary()} mostrada aqui:\\
			
			void disp\_binary()\{
			
			for(int t = 128; t$>$0; t=t/2)
			
			if(i \& t) printf(''1 ");
			
			else printf(''0 ");
			
			printf(''$\backslash$n");
			
			\}\\
			
			La funcion disp\_binary() trabaja testeando cada bit en el byte, usando bitwise AND, para determinar si este está encendido o apagado. Si está encendido, el digito 1 es impreso, de otra forma, se imprime 0. En el capitulo anterior, el campo de bits fue utilizado para imprimir un valor binario (...$\backslash$learn c$\backslash$c union.c). El codigo mostrado aqui, es una mejor alternativa pues es mas rapido y pequeño.
			
			los operadores de shift, $>>$ y $<<$, mueven todos los bits en un valor integral, a la izquirerda o derecha como se especifique. La forma general de shift a la derecha es:\\
			
			\textit{value} $>>$ \textit{number of bit positions}\\
			
			y a la izquierda es:\\
			
			\textit{value} $<<$ \textit{number of bit positions}\\
			
			las operaciones shift pueden ser muy utiles decodificando entradas externas, como convertidores D$\backslash$A y leyendo informacion de estado. Las operaciones bitwise shift pueden ser tambien usadas para realizar muy rapidas multiplicaciones y divisiones de enteros. Un shift a izquierda multiplicará por 2 y un shift a derecha, dividirá sobre 2. Si el tras la multiplicacion es mayor al rango de su tipo, este tendrá una perdida de informacion.\\
			
			El siguiente programa graficamente muestra el efecto de los operadores shift:\\
			
			...$\backslash$learn c$\backslash$c shift.c\\
			
			Una rotacion es similar a es similar aun shift a la derecha, excepto que los bits son shifteados hacia el otro finalpor ejemplo: 1010 rotado a la izquierda es 0101. Una forma de rotar requiere el uso de la union de 2 diferentes tipos de dato, El primer tipo es un arreglo de 2 elementos del tipo de dato que deseas rotar; el segundo metodo es un tipo de dato mas grande que lo que deseas rotar. En este ejemplo se realiza una rotacion bitwise a la izquierda. Por lo tanto, se usa la siguiente union:\\
			
			...$\backslash$learn c$\backslash$c rotate.c\\
			
			Un operador complementario es, ~, este invertirá a los bits, volviendo todos los 1 en 0 y viceversa. Por ejemplo:\\
			
			...$\backslash$learn c$\backslash$c simple$\backslash$ codification.c\\
			
			Las operaciones bitwise son utilizadas seguido en rutinas de cifrado. Se puede usar la funccion \textbf{encode()} cuya definicion es:\\
			
			char encode(char ch)\{
			
			return(~ch);
			
			\}
			
			\subsection{El operador ?}
			
			El operador \textbf{?} es usado para remplazar \textbf{if/else} de esta forma general:\\
			
			if(\textit{condicion}) expresion;
			
			else expresion;\\
			
			La restricción clave es que el blanco de ambos, el \textbf{if} y el \textbf{else} debe ser una sola expresión, no otra sentencia.
			
			El \textbf{?} es llamado un \textit{operador ternario} porque requiere 3 operandos y toma la forma general:\\
			
			\textit{exp1 ? exp2 : exp3}\\
			
			El valor de una expresion \textbf{?} es determinada de esta forma: exp1 es evaluada, si es true, entonces exp2 es evaluada y se vuelve el valor de toda la expresion \textbf{?}. Si es falso exp1 es falso, entonces exp3 es evaluada y se vuelve el valor de la expresion. Por ejemplo:\\
			
			x = 10;
			
			y = x$>$9 ? 100 : 200;\\
			
			En este ejemplo a \textbf{y} se le asignará el valor de 100, si \textbf{x} fuera menor que 9, entonces se le asignaria el valor de 200. El mismo codigo escrito usando sentencias \textbf{if/else} sería:\\
			
			x = 10;
			
			if(x$>$9) y = 100;
			
			else y = 200;\\
			
			Sin embargo, el uso de \textbf{?} para remplazar \textbf{if/else} no se limita a asignaciones. Para ver como su uso puede ser expandido, es importante recordar que todas las funciones (excepto aquellas declaradas void) podrian retornar un valor, por lo tanto es permisible usar una o mas funciones en una expresion de C. Cuando el nombre de la funcion es encontrado, la duncnion es porsupuesto executada tal que su valor de retorno puede ser determinado. Por lo tanto, es posible ejecutar una o mas llamadas de funciones usando el operador \textbf{?}. Por ejemplo:\\
			
			...$\backslash$learn c$\backslash$c simple$\backslash$ op\_ternario.c\\
			
			
			\subsection{Operador coma}
			
			Este operador es usado para encadenar varias expresiones. Por ejemplo:\\
			
			x = (y=3, y+1);\\
			
			Primero asigna a \textbf{y} el valor 3 y despues le asigna a \textbf{x} el valor 4. Los parentesis son necesarios pues la coma tiene menor presedencia al operador de asignacion.
			
			Esencialmente, el efecto de este operador es el de realizar una secuencia de operaciones. Por ejemplo:\\
			
			y = 20;\\
			
			x = (y-=5, 30/y);
			
			\begin{center}
				\begin{tabular}{l l}
					Highest & \hspace{50px} () [] $->$\\
					& \hspace{50px} ! ~ ++ -- - (type) * \& sizeof\\
					& \hspace{50px} * / \%\\
					& \hspace{50px} + -\\
					& \hspace{50px} $<<$ $>>$\\
					& \hspace{50px} $<$ $<=$ $>$ $>=$\\
					& \hspace{50px} == !=\\
					& \hspace{50px} \&\\
					& \hspace{50px} $\wedge$\\
					& \hspace{50px} \textbrokenbar\\
					& \hspace{50px} \&\&\\
					& \hspace{50px} \textbrokenbar\textbrokenbar\\
					& \hspace{50px} ?\\
					& \hspace{50px} = += -= *= /= \\
					Lowest & \hspace{50px} ,
				\end{tabular}
			\end{center}
		
		
	\section{Funciones de control de pantalla}
	
	El desarrollo de progamas exitosos en el ambiente interactivo actual, demanda de total maestría sobre la pantalla. Estas se dividen en 2 modos.
	\begin{itemize}
		\item Texto
		\item Gráfico
	\end{itemize}
	
	En esta seccion, para el desarrollo de control de pantalla en modo texto utilizaremos la libreria \texttt{CURSES.H}. Las referencias respecto al uso de esta libreria se encuentran en el siguiente link:\\
	
	\url{https://tldp.org/HOWTO/NCURSES-Programming-HOWTO/index.html}
	
		
	\section{Estructuras}
	
	Una estructura es la colección de uno o mas elementos denominados miembros; estos pueden ser de un tipo de dato diferente. para declarar una estructura debemos utilizar la palabra reservada \textbf{struct}. para poder definir una estructura debemos de ponerle un nombre. en este caso las estructuras son muy parecidas a los objetos.\\
	
	\textbf{Ejemplo:\\}
	
	...
	
	struct perro
	
	$\lbrace$
	
	char nombre$[$30$]$;
	
	int edadmeses;
	
	float peso;
	
	$\rbrace$perro1=$\lbrace$``gato",10,3.50$\rbrace$,
	
	perro2=$\lbrace$``roberto",4,2.30$\rbrace$;
	
	int main$()$
	
	$\lbrace$
	
	printf$($``El peso de \%s es \%.2f kg y tiene \%d meses $\backslash$n",perro2.nombre,perro2.peso,perro2.edadmeses);
	
	return 0;
	
	$\rbrace$
	
	\subsection{Arreglo de estructuras}
	
	\textbf{Ejemplo:\\}
	
	...
	
	struct perro
	
	$\lbrace$
	
	char nombre$[$30$]$;
	
	int edadmeses;
	
	float peso;
	
	$\rbrace$perros$[$3$]$;
	
	int main$()$
	
	$\lbrace$
	
	for $($int i = 0; i $<$ 3; ++i$)$
	
	$\lbrace$
	
	printf$($``\%iIngresa el nombre del perro$\backslash$n",i+1$)$;
	
	scanf$($``\%s",\&perros$[$i$]$.nombre$)$;
	
	printf$($``\%iIngresa la edad del perro$\backslash$n",i+1$)$;
	
	scanf$($``\%i",\&perros$[$i$]$.edadmeses$)$;
	
	printf$($``\%iIngresa el peso del perro$\backslash$n",i+1$)$;
	
	scanf$($``\%f",\&perros$[$i$]$.peso);
	
	$\rbrace$
	
	for $($int i = 0; i $<$ 3; ++i$)$
	
	$\lbrace$
	
	printf$($``\%i El nombre del perro es: \%s$\backslash$n",i+1,perros$[$i$]$.nombre$)$;
	
	printf$($``\%i La edad del perro es: \%i$\backslash$n",i+1,perros$[$i$]$.edadmeses$)$;
	
	printf$($``\%i El peso del perro es: \%.2f$\backslash$n",i+1,perros$[$i$]$.peso$)$;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$
	
	\subsubsection{Operador punto}
	
	Cada vez que declaramos un arreglo de estructuras para acceder a una variable utilizamos el punto.
	
	\subsection{Estructuras anidadas}
	Las estructuras anidadas siempre se encuentran dentro de otra estructura.\\
	
	\textbf{Ejemplo:\\}
	
	...
	
	\#define length 2
	
	struct owner
	
	$\lbrace$
	
	char nombre$[$20$]$;
	
	char direccion$[$30$]$;
	
	$\rbrace$;
	
	struct dog
	
	$\lbrace$
	
	char nombre$[$20$]$;
	
	int edadmeses;
	
	struct owner ownerDog;
	
	$\rbrace$dogs$[$length$]$;
	
	int main$()$
	
	$\lbrace$
	
	for $($int i = 0; i $<$ length; ++i$)$
	
	$\lbrace$
	
	printf$($``Nombre del perro$\backslash$n"$)$;
	
	scanf$($``\%s",dogs$[$i$]$.nombre$)$;
	
	printf$($``Edad del perro en meses$\backslash$n"$)$;
	
	scanf$($``\%i",\&dogs$[$i$]$.edadmeses$)$;
	
	printf$($``Nombre del dueño$\backslash$n"$)$;
	
	scanf$($``\%s",dogs$[$i$]$.ownerDog.nombre$)$;
	
	printf$($``direccion$\backslash$n"$)$;
	
	scanf$($``\%s",dogs$[$i$]$.ownerDog.direccion$)$;
	
	printf$($``$\backslash$n"$)$;
	
	$\rbrace$
	
	for $($int i = 0; i $<$ length; ++i$)$
	
	$\lbrace$
	
	printf$($``El nombre del perro es: \%s$\backslash$n",dogs$[$i$]$.nombre$)$;
	
	printf$($``Edad en meses del perro: \%i$\backslash$n",dogs$[$i$]$.edadmeses$)$;
	
	printf$($``Nombre del dueño \%s$\backslash$n",dogs$[$i$]$.ownerDog.nombre$)$;
	
	printf$($``La direccion es: \%s$\backslash$n",dogs$[$i$]$.ownerDog.direccion$)$;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$
	
	\section{Asignación dinámica de memoria II}
	
	La memoria es un espacio que reserva nuestra computadora para almacenar algun valor o dato.\\
	
	\textbf{Podemos encontrar:}
	
	\begin{itemize}
		\item Memoria estática
		\item Memoria dinámica
	\end{itemize}
	
	La \textbf{memoria estática} es la que venimos utilizando donde no nos preocupamos por el uso excesivo de la memoria. El problema viene cuando no utilizamos toda la memoria que se le fue asignada; por lo tanto la desperdiciamos, no estamos optimizando nuestro programa para poder utilizar un mínimo de memoria, por lo que tenemos la opción de asignar la memoria dinámica-mente.\\
	
	La \textbf{memoria dinámica $($malloc$)$} es un tipo de memoria que se reserva en tiempo de ejecución, así que su tamaño puede variar al momento de ejecutarse. Es importante utilizarlo cuando no sabemos el numero de datos o elementos que va a contener nuestro programa. Para utilizar malloc es necesario llamar a la librería \textit{stdlib.h}\\
	
	\textbf{Ejemplo 1:\\}
	
	...
	
	int main$()$
	
	$\lbrace$
	
	int n=10;
	
	char * p;
	
	p = malloc$($n*sizeof$($char$))$;
	
	if $($NULL == p$)$
	
	$\lbrace$
	
	printf$($``Error al asignar memoria$\backslash$n"$)$;
	
	$\rbrace$else$\lbrace$
	
	printf$($``Se asignó memoria$\backslash$n"$)$;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$\\
	
	
	\textbf{Ejemplo 2:\\}
	
	\#define length 2
	
	int size;
	
	struct dog
	
	$\lbrace$
	
	char name$[$20$]$;
	
	char *p\_name;
	
	$\rbrace$dogs$[$length$]$;
	
	int main$()$
	
	$\lbrace$
	
	for $($int i = 0; i $<$ length; ++i$)$
	
	$\lbrace$
	
	printf$($``Ingrese el nombre del perro$\backslash$n"$)$;
	
	scanf$($``\%s",dogs$[$i$]$.name$)$;
	
	size = strlen(dogs[i].name);
	
	printf$($``\%i$\backslash$n",size$)$;
	
	dogs$[$i$]$.p\_name = malloc$($size * sizeof$($char$))$;
	
	if $($NULL == dogs$[$i$]$.p\_name$)$
	
	$\lbrace$
	
	printf$($``Error al asignar memoria$\backslash$n"$)$;
	
	$\rbrace$else$\lbrace$
	
	strcpy$($dogs$[$i$]$.p\_name,dogs$[$i$]$.name$)$;
	
	$\rbrace$
	
	$\rbrace$
	
	for $($int i = 0; i $<$ length; ++i$)$
	
	$\lbrace$
	
	printf$($``El nombre del perro es: \%s$\backslash$n",dogs$[$i$]$.p\_name$)$;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$
	
	\subsection{Liberar memoria dinámica}
	
	\subsection{\textit{`fgets' y `free'}}
	
	\textit{\textbf{free}} es lo que se utiliza para liberar la memoria el cual solo necesita de la variable o el apuntador que se va a liberar como parámetro. Como opción a la utilización de \textit{\textbf{scanf}} podemos utilizar \textit{\textbf{gets}}, el cual solo necesita un parámetro que es la dirección de donde se van a archivar los datos; pero puede ser inseguro pues no limita la cantidad de datos que entran al escanear sino se le especifica al arreglo. Sin embargo para evitar este problema utilizamos \textit{\textbf{fgets}} el cual necesita de 3 parámetros:\\
	
	\begin{itemize}
		\item El puntero o la variable donde se va a almacenar la información.
		\item El tamaño de lo que esperamos recibir.
		\item De donde se van a obtener esos datos.
	\end{itemize}
	
	
	
	\subsubsection{Operador}
	
	Cuando hacemos referencia a un puntero utilizamos el operador $->$ haciendo una pequeña flechita. Y de esta forma podemos liberar la memoria de la variable a la que apunta la flecha, pero si tratamos de acceder a ella nos va a ocasionar un problema.\\
	
	\textbf{Ejemplo:\\}
	
	\#include $<$stdio.h$>$
	
	\#include $<$stdlib.h$>$
	
	\#include $<$string.h$>$
	
	\#define length 2
	
	int size;
	
	struct dog
	
	$\lbrace$
	
	char name$[$20$]$;
	
	char *p\_name;
	
	$\rbrace$dogs$[$length$]$;
	
	int main$()$
	
	$\lbrace$
	
	for $($int i = 0; i $<$ length; ++i$)$
	
	$\lbrace$
	
	printf$($``Ingrese el nombre del perro$\backslash$n");
	
	fgets$($dogs$[$i$]$.name,20,stdin$)$;
	
	size = strlen$($dogs$[$i$]$.name$)$;
	
	printf$($``\%i$\backslash$n",size$)$;
	
	dogs$[$i$]$.p\_name = malloc$($size * sizeof$($char$))$;
	
	if $($NULL == dogs$[$i$]$.p\_name$)$
	
	$\lbrace$
	
	printf$($``Error al asignar memoria$\backslash$n"$)$;
	
	$\rbrace$else$\lbrace$
	
	strcpy$($dogs$[$i$]$.p\_name,dogs$[$i$]$.name$)$;
	
	free$($dogs$[$i$]$.name$)$;
	
	$\lbrace$
	
	$\rbrace$
	
	for $($int i = 0; i $<$ length; ++i$)$
	
	$\lbrace$
	
	printf$($``El nombre del perro es: \%s$\backslash$n",dogs$[$i$]$.p\_name$)$;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$
	
	\section{Listas enlazadas}
	
	Son una colección de estructuras autorreferenciadas llamadas \textit{\textbf{nodos}}. en las listas enlazadas podemos guardar y eliminar datos en tiempo de ejecución y no es necesario definir cuantos espacios va a tener nuestra lista.\\
	
	En esta definición hablamos de estructuras autorreferenciadas. >Que es una estructura autorreferenciada? Una estructura autorreferenciada contiene un miembro apuntador el cual apunta a una estructura del mismo tipo.\\
	
	Ahora >Que es un nodo en C? Un nodo en C es una estructura que se crea con memoria dinámica; también al momento en que creamos estructuras nos podemos encontrar con algo llamado \textit{\textbf{typedef}} que se antepone a la estructura nos permite crear sinónimos para nuestras estructuras.\\
	
	\textbf{Ejemplo:}
	
	\#include $<$stdio.h$>$
	
	\#include $<$stdlib.h$>$
	
	typedef struct nodo
	
	$\lbrace$
	
	char *nombre;
	
	struct nodo *sig;
	
	$\rbrace$Libro;
	
	Libro *listaLibro$($Libro *Lista$)$$\lbrace$
	
	Lista = NULL;
	
	return Lista;
	
	$\rbrace$
	
	Libro *agregarLibro$($Libro *Lista, char *nombre$)$$\lbrace$
	
	Libro *nuevoLibro, *aux;
	
	nuevoLibro = $($Libro*$)$malloc$($sizeof$($Libro$))$;
	
	nuevoLibro$->$nombre = nombre;
	
	nuevoLibro$->$sig = NULL;
	
	if $($Lista == NULL$)$
	
	$\lbrace$
	
	Lista = nuevoLibro;
	
	$\rbrace$else$\lbrace$
	
	aux = Lista;
	
	while$($aux$->$sig !=NULL$)$$\lbrace$
	
	aux = aux$->$sig;
	
	$\rbrace$
	
	aux$->$sig = nuevoLibro;
	
	$\rbrace$
	
	return Lista;
	
	$\rbrace$
	
	int main$()$
	
	$\lbrace$
	
	Libro *Lista = listaLibro$($Lista$)$;
	
	Lista = agregarLibro$($Lista,``HTML5 Avanzado"$)$;
	
	Lista = agregarLibro$($Lista,``CSS3 Avanzado"$)$;
	
	while$($Lista != NULL$)$$\lbrace$
	
	printf$($``\%s$\backslash$n",Lista$->$nombre$)$;
	
	Lista = Lista$->$sig;
	
	$\rbrace$
	
	return 0;
	
	$\rbrace$
	
\end{document}$